<?php
/**
 * CourseApi
 * PHP version 7.3
 *
 * @category Class
 * @package  RusticiSoftware\Engine\V2
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Rustici Engine API
 *
 * Rustici Engine API
 *
 * The version of the OpenAPI document: 2.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace RusticiSoftware\Engine\V2\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use RusticiSoftware\Engine\V2\ApiException;
use RusticiSoftware\Engine\V2\Configuration;
use RusticiSoftware\Engine\V2\HeaderSelector;
use RusticiSoftware\Engine\V2\ObjectSerializer;

/**
 * CourseApi Class Doc Comment
 *
 * @category Class
 * @package  RusticiSoftware\Engine\V2
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CourseApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation buildCoursePreviewLaunchLink
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function buildCoursePreviewLaunchLink($engine_tenant_name, $course_id, $launch_link_request)
    {
        list($response) = $this->buildCoursePreviewLaunchLinkWithHttpInfo($engine_tenant_name, $course_id, $launch_link_request);
        return $response;
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithHttpInfo
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildCoursePreviewLaunchLinkWithHttpInfo($engine_tenant_name, $course_id, $launch_link_request)
    {
        $request = $this->buildCoursePreviewLaunchLinkRequest($engine_tenant_name, $course_id, $launch_link_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildCoursePreviewLaunchLinkAsync
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkAsync($engine_tenant_name, $course_id, $launch_link_request)
    {
        return $this->buildCoursePreviewLaunchLinkAsyncWithHttpInfo($engine_tenant_name, $course_id, $launch_link_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkAsyncWithHttpInfo
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkAsyncWithHttpInfo($engine_tenant_name, $course_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkRequest($engine_tenant_name, $course_id, $launch_link_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildCoursePreviewLaunchLink'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function buildCoursePreviewLaunchLinkRequest($engine_tenant_name, $course_id, $launch_link_request)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling buildCoursePreviewLaunchLink'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling buildCoursePreviewLaunchLink'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildCoursePreviewLaunchLink'
            );
        }

        $resourcePath = '/courses/{courseId}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($launch_link_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($launch_link_request));
            } else {
                $httpBody = $launch_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersion
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function buildCoursePreviewLaunchLinkWithVersion($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        list($response) = $this->buildCoursePreviewLaunchLinkWithVersionWithHttpInfo($engine_tenant_name, $course_id, $version_id, $launch_link_request);
        return $response;
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionWithHttpInfo
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildCoursePreviewLaunchLinkWithVersionWithHttpInfo($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        $request = $this->buildCoursePreviewLaunchLinkWithVersionRequest($engine_tenant_name, $course_id, $version_id, $launch_link_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionAsync
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkWithVersionAsync($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        return $this->buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $launch_link_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkWithVersionRequest($engine_tenant_name, $course_id, $version_id, $launch_link_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildCoursePreviewLaunchLinkWithVersion'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function buildCoursePreviewLaunchLinkWithVersionRequest($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($launch_link_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($launch_link_request));
            } else {
                $httpBody = $launch_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFetchAndImportCourseJob
     *
     * Start a job to fetch and import a course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function createFetchAndImportCourseJob($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false)
    {
        list($response) = $this->createFetchAndImportCourseJobWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version);
        return $response;
    }

    /**
     * Operation createFetchAndImportCourseJobWithHttpInfo
     *
     * Start a job to fetch and import a course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFetchAndImportCourseJobWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false)
    {
        $request = $this->createFetchAndImportCourseJobRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\StringResultSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\StringResultSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFetchAndImportCourseJobAsync
     *
     * Start a job to fetch and import a course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFetchAndImportCourseJobAsync($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false)
    {
        return $this->createFetchAndImportCourseJobAsyncWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFetchAndImportCourseJobAsyncWithHttpInfo
     *
     * Start a job to fetch and import a course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFetchAndImportCourseJobAsyncWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createFetchAndImportCourseJobRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFetchAndImportCourseJob'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFetchAndImportCourseJobRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling createFetchAndImportCourseJob'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createFetchAndImportCourseJob'
            );
        }
        // verify the required parameter 'import_request' is set
        if ($import_request === null || (is_array($import_request) && count($import_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_request when calling createFetchAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($course_id)) {
            $course_id = ObjectSerializer::serializeCollection($course_id, '', true);
        }
        if ($course_id !== null) {
            $queryParams['courseId'] = $course_id;
        }
        // query params
        if (is_array($may_create_new_version)) {
            $may_create_new_version = ObjectSerializer::serializeCollection($may_create_new_version, '', true);
        }
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = $may_create_new_version;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($import_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($import_request));
            } else {
                $httpBody = $import_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createUploadAndImportCourseJob
     *
     * Upload a course and start an import job for it.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function createUploadAndImportCourseJob($engine_tenant_name, $course_id, $may_create_new_version = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        list($response) = $this->createUploadAndImportCourseJobWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version, $uploaded_content_type, $file, $content_metadata);
        return $response;
    }

    /**
     * Operation createUploadAndImportCourseJobWithHttpInfo
     *
     * Upload a course and start an import job for it.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUploadAndImportCourseJobWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        $request = $this->createUploadAndImportCourseJobRequest($engine_tenant_name, $course_id, $may_create_new_version, $uploaded_content_type, $file, $content_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\StringResultSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\StringResultSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createUploadAndImportCourseJobAsync
     *
     * Upload a course and start an import job for it.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadAndImportCourseJobAsync($engine_tenant_name, $course_id, $may_create_new_version = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        return $this->createUploadAndImportCourseJobAsyncWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version, $uploaded_content_type, $file, $content_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUploadAndImportCourseJobAsyncWithHttpInfo
     *
     * Upload a course and start an import job for it.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadAndImportCourseJobAsyncWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createUploadAndImportCourseJobRequest($engine_tenant_name, $course_id, $may_create_new_version, $uploaded_content_type, $file, $content_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUploadAndImportCourseJob'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createUploadAndImportCourseJobRequest($engine_tenant_name, $course_id, $may_create_new_version = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling createUploadAndImportCourseJob'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createUploadAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($course_id)) {
            $course_id = ObjectSerializer::serializeCollection($course_id, '', true);
        }
        if ($course_id !== null) {
            $queryParams['courseId'] = $course_id;
        }
        // query params
        if (is_array($may_create_new_version)) {
            $may_create_new_version = ObjectSerializer::serializeCollection($may_create_new_version, '', true);
        }
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = $may_create_new_version;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }
        // header params
        if ($uploaded_content_type !== null) {
            $headerParams['uploadedContentType'] = ObjectSerializer::toHeaderValue($uploaded_content_type);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($content_metadata !== null) {
            $formParams['contentMetadata'] = ObjectSerializer::toFormValue($content_metadata);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourse
     *
     * Delete &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourse($engine_tenant_name, $course_id)
    {
        $this->deleteCourseWithHttpInfo($engine_tenant_name, $course_id);
    }

    /**
     * Operation deleteCourseWithHttpInfo
     *
     * Delete &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseWithHttpInfo($engine_tenant_name, $course_id)
    {
        $request = $this->deleteCourseRequest($engine_tenant_name, $course_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseAsync
     *
     * Delete &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAsync($engine_tenant_name, $course_id)
    {
        return $this->deleteCourseAsyncWithHttpInfo($engine_tenant_name, $course_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseAsyncWithHttpInfo
     *
     * Delete &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAsyncWithHttpInfo($engine_tenant_name, $course_id)
    {
        $returnType = '';
        $request = $this->deleteCourseRequest($engine_tenant_name, $course_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourse'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCourseRequest($engine_tenant_name, $course_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourse'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourse'
            );
        }

        $resourcePath = '/courses/{courseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseAsset
     *
     * Delete the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseAsset($engine_tenant_name, $course_id, $relative_path)
    {
        $this->deleteCourseAssetWithHttpInfo($engine_tenant_name, $course_id, $relative_path);
    }

    /**
     * Operation deleteCourseAssetWithHttpInfo
     *
     * Delete the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseAssetWithHttpInfo($engine_tenant_name, $course_id, $relative_path)
    {
        $request = $this->deleteCourseAssetRequest($engine_tenant_name, $course_id, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseAssetAsync
     *
     * Delete the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAssetAsync($engine_tenant_name, $course_id, $relative_path)
    {
        return $this->deleteCourseAssetAsyncWithHttpInfo($engine_tenant_name, $course_id, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseAssetAsyncWithHttpInfo
     *
     * Delete the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAssetAsyncWithHttpInfo($engine_tenant_name, $course_id, $relative_path)
    {
        $returnType = '';
        $request = $this->deleteCourseAssetRequest($engine_tenant_name, $course_id, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseAsset'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCourseAssetRequest($engine_tenant_name, $course_id, $relative_path)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseAsset'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseAsset'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling deleteCourseAsset'
            );
        }

        $resourcePath = '/courses/{courseId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($relative_path)) {
            $relative_path = ObjectSerializer::serializeCollection($relative_path, '', true);
        }
        if ($relative_path !== null) {
            $queryParams['relativePath'] = $relative_path;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseConfigurationSetting
     *
     * Clears the &#x60;settingId&#x60; value for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseConfigurationSetting($engine_tenant_name, $course_id, $setting_id)
    {
        $this->deleteCourseConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $setting_id);
    }

    /**
     * Operation deleteCourseConfigurationSettingWithHttpInfo
     *
     * Clears the &#x60;settingId&#x60; value for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
    {
        $request = $this->deleteCourseConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseConfigurationSettingAsync
     *
     * Clears the &#x60;settingId&#x60; value for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseConfigurationSettingAsync($engine_tenant_name, $course_id, $setting_id)
    {
        return $this->deleteCourseConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseConfigurationSettingAsyncWithHttpInfo
     *
     * Clears the &#x60;settingId&#x60; value for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseConfigurationSetting'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCourseConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseConfigurationSetting'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersion
     *
     * Delete version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersion($engine_tenant_name, $course_id, $version_id)
    {
        $this->deleteCourseVersionWithHttpInfo($engine_tenant_name, $course_id, $version_id);
    }

    /**
     * Operation deleteCourseVersionWithHttpInfo
     *
     * Delete version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionWithHttpInfo($engine_tenant_name, $course_id, $version_id)
    {
        $request = $this->deleteCourseVersionRequest($engine_tenant_name, $course_id, $version_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionAsync
     *
     * Delete version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAsync($engine_tenant_name, $course_id, $version_id)
    {
        return $this->deleteCourseVersionAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionAsyncWithHttpInfo
     *
     * Delete version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionRequest($engine_tenant_name, $course_id, $version_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersion'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCourseVersionRequest($engine_tenant_name, $course_id, $version_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseVersion'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersion'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersion'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersionAsset
     *
     * Delete the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersionAsset($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        $this->deleteCourseVersionAssetWithHttpInfo($engine_tenant_name, $course_id, $version_id, $relative_path);
    }

    /**
     * Operation deleteCourseVersionAssetWithHttpInfo
     *
     * Delete the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionAssetWithHttpInfo($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        $request = $this->deleteCourseVersionAssetRequest($engine_tenant_name, $course_id, $version_id, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionAssetAsync
     *
     * Delete the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAssetAsync($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        return $this->deleteCourseVersionAssetAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionAssetAsyncWithHttpInfo
     *
     * Delete the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAssetAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionAssetRequest($engine_tenant_name, $course_id, $version_id, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersionAsset'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCourseVersionAssetRequest($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseVersionAsset'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersionAsset'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersionAsset'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling deleteCourseVersionAsset'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($relative_path)) {
            $relative_path = ObjectSerializer::serializeCollection($relative_path, '', true);
        }
        if ($relative_path !== null) {
            $queryParams['relativePath'] = $relative_path;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersionConfigurationSetting
     *
     * Clears the &#x60;settingId&#x60; value for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersionConfigurationSetting($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        $this->deleteCourseVersionConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $version_id, $setting_id);
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingWithHttpInfo
     *
     * Clears the &#x60;settingId&#x60; value for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        $request = $this->deleteCourseVersionConfigurationSettingRequest($engine_tenant_name, $course_id, $version_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingAsync
     *
     * Clears the &#x60;settingId&#x60; value for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionConfigurationSettingAsync($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        return $this->deleteCourseVersionConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingAsyncWithHttpInfo
     *
     * Clears the &#x60;settingId&#x60; value for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionConfigurationSettingRequest($engine_tenant_name, $course_id, $version_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersionConfigurationSetting'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCourseVersionConfigurationSettingRequest($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseVersionConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersionsConfigurationSetting
     *
     * Clears the &#x60;settingId&#x60; value for all versions of this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersionsConfigurationSetting($engine_tenant_name, $course_id, $setting_id)
    {
        $this->deleteCourseVersionsConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $setting_id);
    }

    /**
     * Operation deleteCourseVersionsConfigurationSettingWithHttpInfo
     *
     * Clears the &#x60;settingId&#x60; value for all versions of this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionsConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
    {
        $request = $this->deleteCourseVersionsConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionsConfigurationSettingAsync
     *
     * Clears the &#x60;settingId&#x60; value for all versions of this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionsConfigurationSettingAsync($engine_tenant_name, $course_id, $setting_id)
    {
        return $this->deleteCourseVersionsConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionsConfigurationSettingAsyncWithHttpInfo
     *
     * Clears the &#x60;settingId&#x60; value for all versions of this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionsConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionsConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersionsConfigurationSetting'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCourseVersionsConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseVersionsConfigurationSetting'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersionsConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseVersionsConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseZip
     *
     * Deletes the exported zip for the latest version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $export_type export_type (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseZip($engine_tenant_name, $course_id, $export_type)
    {
        $this->deleteCourseZipWithHttpInfo($engine_tenant_name, $course_id, $export_type);
    }

    /**
     * Operation deleteCourseZipWithHttpInfo
     *
     * Deletes the exported zip for the latest version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $export_type (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseZipWithHttpInfo($engine_tenant_name, $course_id, $export_type)
    {
        $request = $this->deleteCourseZipRequest($engine_tenant_name, $course_id, $export_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseZipAsync
     *
     * Deletes the exported zip for the latest version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseZipAsync($engine_tenant_name, $course_id, $export_type)
    {
        return $this->deleteCourseZipAsyncWithHttpInfo($engine_tenant_name, $course_id, $export_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseZipAsyncWithHttpInfo
     *
     * Deletes the exported zip for the latest version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseZipAsyncWithHttpInfo($engine_tenant_name, $course_id, $export_type)
    {
        $returnType = '';
        $request = $this->deleteCourseZipRequest($engine_tenant_name, $course_id, $export_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseZip'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCourseZipRequest($engine_tenant_name, $course_id, $export_type)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseZip'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseZip'
            );
        }
        // verify the required parameter 'export_type' is set
        if ($export_type === null || (is_array($export_type) && count($export_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_type when calling deleteCourseZip'
            );
        }

        $resourcePath = '/courses/{courseId}/zip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($export_type)) {
            $export_type = ObjectSerializer::serializeCollection($export_type, '', true);
        }
        if ($export_type !== null) {
            $queryParams['exportType'] = $export_type;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVersionedCourseZip
     *
     * Deletes the exported zip for the specified course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type export_type (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteVersionedCourseZip($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        $this->deleteVersionedCourseZipWithHttpInfo($engine_tenant_name, $course_id, $version_id, $export_type);
    }

    /**
     * Operation deleteVersionedCourseZipWithHttpInfo
     *
     * Deletes the exported zip for the specified course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVersionedCourseZipWithHttpInfo($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        $request = $this->deleteVersionedCourseZipRequest($engine_tenant_name, $course_id, $version_id, $export_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteVersionedCourseZipAsync
     *
     * Deletes the exported zip for the specified course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVersionedCourseZipAsync($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        return $this->deleteVersionedCourseZipAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $export_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVersionedCourseZipAsyncWithHttpInfo
     *
     * Deletes the exported zip for the specified course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVersionedCourseZipAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        $returnType = '';
        $request = $this->deleteVersionedCourseZipRequest($engine_tenant_name, $course_id, $version_id, $export_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVersionedCourseZip'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteVersionedCourseZipRequest($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteVersionedCourseZip'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteVersionedCourseZip'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteVersionedCourseZip'
            );
        }
        // verify the required parameter 'export_type' is set
        if ($export_type === null || (is_array($export_type) && count($export_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_type when calling deleteVersionedCourseZip'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/zip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($export_type)) {
            $export_type = ObjectSerializer::serializeCollection($export_type, '', true);
        }
        if ($export_type !== null) {
            $queryParams['exportType'] = $export_type;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourse
     *
     * Get information about &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CourseSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourse($engine_tenant_name, $course_id, $include_registration_count = false, $include_course_metadata = false)
    {
        list($response) = $this->getCourseWithHttpInfo($engine_tenant_name, $course_id, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseWithHttpInfo
     *
     * Get information about &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CourseSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseWithHttpInfo($engine_tenant_name, $course_id, $include_registration_count = false, $include_course_metadata = false)
    {
        $request = $this->getCourseRequest($engine_tenant_name, $course_id, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\CourseSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\CourseSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\CourseSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CourseSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseAsync
     *
     * Get information about &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAsync($engine_tenant_name, $course_id, $include_registration_count = false, $include_course_metadata = false)
    {
        return $this->getCourseAsyncWithHttpInfo($engine_tenant_name, $course_id, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseAsyncWithHttpInfo
     *
     * Get information about &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAsyncWithHttpInfo($engine_tenant_name, $course_id, $include_registration_count = false, $include_course_metadata = false)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseSchema';
        $request = $this->getCourseRequest($engine_tenant_name, $course_id, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourse'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseRequest($engine_tenant_name, $course_id, $include_registration_count = false, $include_course_metadata = false)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourse'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourse'
            );
        }

        $resourcePath = '/courses/{courseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($include_registration_count)) {
            $include_registration_count = ObjectSerializer::serializeCollection($include_registration_count, '', true);
        }
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = $include_registration_count;
        }
        // query params
        if (is_array($include_course_metadata)) {
            $include_course_metadata = ObjectSerializer::serializeCollection($include_course_metadata, '', true);
        }
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = $include_course_metadata;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseAsset
     *
     * Get the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseAsset($engine_tenant_name, $course_id, $relative_path)
    {
        list($response) = $this->getCourseAssetWithHttpInfo($engine_tenant_name, $course_id, $relative_path);
        return $response;
    }

    /**
     * Operation getCourseAssetWithHttpInfo
     *
     * Get the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseAssetWithHttpInfo($engine_tenant_name, $course_id, $relative_path)
    {
        $request = $this->getCourseAssetRequest($engine_tenant_name, $course_id, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseAssetAsync
     *
     * Get the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAssetAsync($engine_tenant_name, $course_id, $relative_path)
    {
        return $this->getCourseAssetAsyncWithHttpInfo($engine_tenant_name, $course_id, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseAssetAsyncWithHttpInfo
     *
     * Get the specified asset in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAssetAsyncWithHttpInfo($engine_tenant_name, $course_id, $relative_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCourseAssetRequest($engine_tenant_name, $course_id, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseAsset'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseAssetRequest($engine_tenant_name, $course_id, $relative_path)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseAsset'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseAsset'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling getCourseAsset'
            );
        }

        $resourcePath = '/courses/{courseId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($relative_path)) {
            $relative_path = ObjectSerializer::serializeCollection($relative_path, '', true);
        }
        if ($relative_path !== null) {
            $queryParams['relativePath'] = $relative_path;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseConfiguration
     *
     * Returns all configuration settings for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SettingListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseConfiguration($engine_tenant_name, $course_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        list($response) = $this->getCourseConfigurationWithHttpInfo($engine_tenant_name, $course_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);
        return $response;
    }

    /**
     * Operation getCourseConfigurationWithHttpInfo
     *
     * Returns all configuration settings for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SettingListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseConfigurationWithHttpInfo($engine_tenant_name, $course_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        $request = $this->getCourseConfigurationRequest($engine_tenant_name, $course_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\SettingListSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\SettingListSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseConfigurationAsync
     *
     * Returns all configuration settings for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseConfigurationAsync($engine_tenant_name, $course_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        return $this->getCourseConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseConfigurationAsyncWithHttpInfo
     *
     * Returns all configuration settings for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getCourseConfigurationRequest($engine_tenant_name, $course_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseConfigurationRequest($engine_tenant_name, $course_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($include_metadata)) {
            $include_metadata = ObjectSerializer::serializeCollection($include_metadata, '', true);
        }
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = $include_metadata;
        }
        // query params
        if (is_array($include_hidden_settings)) {
            $include_hidden_settings = ObjectSerializer::serializeCollection($include_hidden_settings, '', true);
        }
        if ($include_hidden_settings !== null) {
            $queryParams['includeHiddenSettings'] = $include_hidden_settings;
        }
        // query params
        if (is_array($include_secret_settings)) {
            $include_secret_settings = ObjectSerializer::serializeCollection($include_secret_settings, '', true);
        }
        if ($include_secret_settings !== null) {
            $queryParams['includeSecretSettings'] = $include_secret_settings;
        }
        // query params
        if (is_array($process_replacement_tokens)) {
            $process_replacement_tokens = ObjectSerializer::serializeCollection($process_replacement_tokens, '', true);
        }
        if ($process_replacement_tokens !== null) {
            $queryParams['processReplacementTokens'] = $process_replacement_tokens;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseFileList
     *
     * Get the list of files in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\FileListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseFileList($engine_tenant_name, $course_id)
    {
        list($response) = $this->getCourseFileListWithHttpInfo($engine_tenant_name, $course_id);
        return $response;
    }

    /**
     * Operation getCourseFileListWithHttpInfo
     *
     * Get the list of files in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\FileListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseFileListWithHttpInfo($engine_tenant_name, $course_id)
    {
        $request = $this->getCourseFileListRequest($engine_tenant_name, $course_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\FileListSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\FileListSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\FileListSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\FileListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseFileListAsync
     *
     * Get the list of files in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseFileListAsync($engine_tenant_name, $course_id)
    {
        return $this->getCourseFileListAsyncWithHttpInfo($engine_tenant_name, $course_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseFileListAsyncWithHttpInfo
     *
     * Get the list of files in the current version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseFileListAsyncWithHttpInfo($engine_tenant_name, $course_id)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\FileListSchema';
        $request = $this->getCourseFileListRequest($engine_tenant_name, $course_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseFileList'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseFileListRequest($engine_tenant_name, $course_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseFileList'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseFileList'
            );
        }

        $resourcePath = '/courses/{courseId}/asset/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseStatements
     *
     * Get xAPI statements for &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\XapiStatementResult|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseStatements($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getCourseStatementsWithHttpInfo($engine_tenant_name, $course_id, $learner_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getCourseStatementsWithHttpInfo
     *
     * Get xAPI statements for &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\XapiStatementResult|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseStatementsWithHttpInfo($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $request = $this->getCourseStatementsRequest($engine_tenant_name, $course_id, $learner_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\XapiStatementResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\XapiStatementResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseStatementsAsync
     *
     * Get xAPI statements for &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseStatementsAsync($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        return $this->getCourseStatementsAsyncWithHttpInfo($engine_tenant_name, $course_id, $learner_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseStatementsAsyncWithHttpInfo($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getCourseStatementsRequest($engine_tenant_name, $course_id, $learner_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseStatements'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseStatementsRequest($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseStatements'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseStatements'
            );
        }

        $resourcePath = '/courses/{courseId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($learner_id)) {
            $learner_id = ObjectSerializer::serializeCollection($learner_id, '', true);
        }
        if ($learner_id !== null) {
            $queryParams['learnerId'] = $learner_id;
        }
        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($until)) {
            $until = ObjectSerializer::serializeCollection($until, '', true);
        }
        if ($until !== null) {
            $queryParams['until'] = $until;
        }
        // query params
        if (is_array($more)) {
            $more = ObjectSerializer::serializeCollection($more, '', true);
        }
        if ($more !== null) {
            $queryParams['more'] = $more;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionAsset
     *
     * Get the specified asset for this course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseVersionAsset($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        list($response) = $this->getCourseVersionAssetWithHttpInfo($engine_tenant_name, $course_id, $version_id, $relative_path);
        return $response;
    }

    /**
     * Operation getCourseVersionAssetWithHttpInfo
     *
     * Get the specified asset for this course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionAssetWithHttpInfo($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        $request = $this->getCourseVersionAssetRequest($engine_tenant_name, $course_id, $version_id, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionAssetAsync
     *
     * Get the specified asset for this course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionAssetAsync($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        return $this->getCourseVersionAssetAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionAssetAsyncWithHttpInfo
     *
     * Get the specified asset for this course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionAssetAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCourseVersionAssetRequest($engine_tenant_name, $course_id, $version_id, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionAsset'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseVersionAssetRequest($engine_tenant_name, $course_id, $version_id, $relative_path)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersionAsset'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionAsset'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionAsset'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling getCourseVersionAsset'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($relative_path)) {
            $relative_path = ObjectSerializer::serializeCollection($relative_path, '', true);
        }
        if ($relative_path !== null) {
            $queryParams['relativePath'] = $relative_path;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionConfiguration
     *
     * Returns all configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SettingListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseVersionConfiguration($engine_tenant_name, $course_id, $version_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        list($response) = $this->getCourseVersionConfigurationWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);
        return $response;
    }

    /**
     * Operation getCourseVersionConfigurationWithHttpInfo
     *
     * Returns all configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SettingListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionConfigurationWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        $request = $this->getCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\SettingListSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\SettingListSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionConfigurationAsync
     *
     * Returns all configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionConfigurationAsync($engine_tenant_name, $course_id, $version_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        return $this->getCourseVersionConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionConfigurationAsyncWithHttpInfo
     *
     * Returns all configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($include_metadata)) {
            $include_metadata = ObjectSerializer::serializeCollection($include_metadata, '', true);
        }
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = $include_metadata;
        }
        // query params
        if (is_array($include_hidden_settings)) {
            $include_hidden_settings = ObjectSerializer::serializeCollection($include_hidden_settings, '', true);
        }
        if ($include_hidden_settings !== null) {
            $queryParams['includeHiddenSettings'] = $include_hidden_settings;
        }
        // query params
        if (is_array($include_secret_settings)) {
            $include_secret_settings = ObjectSerializer::serializeCollection($include_secret_settings, '', true);
        }
        if ($include_secret_settings !== null) {
            $queryParams['includeSecretSettings'] = $include_secret_settings;
        }
        // query params
        if (is_array($process_replacement_tokens)) {
            $process_replacement_tokens = ObjectSerializer::serializeCollection($process_replacement_tokens, '', true);
        }
        if ($process_replacement_tokens !== null) {
            $queryParams['processReplacementTokens'] = $process_replacement_tokens;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionFileList
     *
     * Get the list of files in the specified version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\FileListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseVersionFileList($engine_tenant_name, $course_id, $version_id)
    {
        list($response) = $this->getCourseVersionFileListWithHttpInfo($engine_tenant_name, $course_id, $version_id);
        return $response;
    }

    /**
     * Operation getCourseVersionFileListWithHttpInfo
     *
     * Get the list of files in the specified version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\FileListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionFileListWithHttpInfo($engine_tenant_name, $course_id, $version_id)
    {
        $request = $this->getCourseVersionFileListRequest($engine_tenant_name, $course_id, $version_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\FileListSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\FileListSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\FileListSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\FileListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionFileListAsync
     *
     * Get the list of files in the specified version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionFileListAsync($engine_tenant_name, $course_id, $version_id)
    {
        return $this->getCourseVersionFileListAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionFileListAsyncWithHttpInfo
     *
     * Get the list of files in the specified version of the specified course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionFileListAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\FileListSchema';
        $request = $this->getCourseVersionFileListRequest($engine_tenant_name, $course_id, $version_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionFileList'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseVersionFileListRequest($engine_tenant_name, $course_id, $version_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersionFileList'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionFileList'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionFileList'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionInfo
     *
     * Get version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CourseSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseVersionInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count = false, $include_course_metadata = false)
    {
        list($response) = $this->getCourseVersionInfoWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionInfoWithHttpInfo
     *
     * Get version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CourseSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionInfoWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count = false, $include_course_metadata = false)
    {
        $request = $this->getCourseVersionInfoRequest($engine_tenant_name, $course_id, $version_id, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\CourseSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\CourseSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\CourseSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CourseSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionInfoAsync
     *
     * Get version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionInfoAsync($engine_tenant_name, $course_id, $version_id, $include_registration_count = false, $include_course_metadata = false)
    {
        return $this->getCourseVersionInfoAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionInfoAsyncWithHttpInfo
     *
     * Get version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionInfoAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count = false, $include_course_metadata = false)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseSchema';
        $request = $this->getCourseVersionInfoRequest($engine_tenant_name, $course_id, $version_id, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionInfo'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseVersionInfoRequest($engine_tenant_name, $course_id, $version_id, $include_registration_count = false, $include_course_metadata = false)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersionInfo'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionInfo'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionInfo'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($include_registration_count)) {
            $include_registration_count = ObjectSerializer::serializeCollection($include_registration_count, '', true);
        }
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = $include_registration_count;
        }
        // query params
        if (is_array($include_course_metadata)) {
            $include_course_metadata = ObjectSerializer::serializeCollection($include_course_metadata, '', true);
        }
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = $include_course_metadata;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionStatements
     *
     * Get xAPI statements for version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\XapiStatementResult|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseVersionStatements($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getCourseVersionStatementsWithHttpInfo($engine_tenant_name, $course_id, $version_id, $learner_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getCourseVersionStatementsWithHttpInfo
     *
     * Get xAPI statements for version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\XapiStatementResult|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionStatementsWithHttpInfo($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $request = $this->getCourseVersionStatementsRequest($engine_tenant_name, $course_id, $version_id, $learner_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\XapiStatementResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\XapiStatementResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionStatementsAsync
     *
     * Get xAPI statements for version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionStatementsAsync($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        return $this->getCourseVersionStatementsAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $learner_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for version &#x60;versionId&#x60; of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionStatementsAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getCourseVersionStatementsRequest($engine_tenant_name, $course_id, $version_id, $learner_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionStatements'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseVersionStatementsRequest($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersionStatements'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionStatements'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionStatements'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($learner_id)) {
            $learner_id = ObjectSerializer::serializeCollection($learner_id, '', true);
        }
        if ($learner_id !== null) {
            $queryParams['learnerId'] = $learner_id;
        }
        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($until)) {
            $until = ObjectSerializer::serializeCollection($until, '', true);
        }
        if ($until !== null) {
            $queryParams['until'] = $until;
        }
        // query params
        if (is_array($more)) {
            $more = ObjectSerializer::serializeCollection($more, '', true);
        }
        if ($more !== null) {
            $queryParams['more'] = $more;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersions
     *
     * Get all versions of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseVersions($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        list($response) = $this->getCourseVersionsWithHttpInfo($engine_tenant_name, $course_id, $since, $until, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionsWithHttpInfo
     *
     * Get all versions of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionsWithHttpInfo($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        $request = $this->getCourseVersionsRequest($engine_tenant_name, $course_id, $since, $until, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionsAsync
     *
     * Get all versions of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionsAsync($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        return $this->getCourseVersionsAsyncWithHttpInfo($engine_tenant_name, $course_id, $since, $until, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionsAsyncWithHttpInfo
     *
     * Get all versions of &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionsAsyncWithHttpInfo($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema';
        $request = $this->getCourseVersionsRequest($engine_tenant_name, $course_id, $since, $until, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersions'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseVersionsRequest($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersions'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersions'
            );
        }

        $resourcePath = '/courses/{courseId}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($until)) {
            $until = ObjectSerializer::serializeCollection($until, '', true);
        }
        if ($until !== null) {
            $queryParams['until'] = $until;
        }
        // query params
        if (is_array($include_registration_count)) {
            $include_registration_count = ObjectSerializer::serializeCollection($include_registration_count, '', true);
        }
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = $include_registration_count;
        }
        // query params
        if (is_array($include_course_metadata)) {
            $include_course_metadata = ObjectSerializer::serializeCollection($include_course_metadata, '', true);
        }
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = $include_course_metadata;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseZip
     *
     * Get the zip package for the latest course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $export_type export_type (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourseZip($engine_tenant_name, $course_id, $export_type)
    {
        list($response) = $this->getCourseZipWithHttpInfo($engine_tenant_name, $course_id, $export_type);
        return $response;
    }

    /**
     * Operation getCourseZipWithHttpInfo
     *
     * Get the zip package for the latest course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $export_type (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseZipWithHttpInfo($engine_tenant_name, $course_id, $export_type)
    {
        $request = $this->getCourseZipRequest($engine_tenant_name, $course_id, $export_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseZipAsync
     *
     * Get the zip package for the latest course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseZipAsync($engine_tenant_name, $course_id, $export_type)
    {
        return $this->getCourseZipAsyncWithHttpInfo($engine_tenant_name, $course_id, $export_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseZipAsyncWithHttpInfo
     *
     * Get the zip package for the latest course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseZipAsyncWithHttpInfo($engine_tenant_name, $course_id, $export_type)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCourseZipRequest($engine_tenant_name, $course_id, $export_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseZip'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCourseZipRequest($engine_tenant_name, $course_id, $export_type)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseZip'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseZip'
            );
        }
        // verify the required parameter 'export_type' is set
        if ($export_type === null || (is_array($export_type) && count($export_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_type when calling getCourseZip'
            );
        }

        $resourcePath = '/courses/{courseId}/zip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($export_type)) {
            $export_type = ObjectSerializer::serializeCollection($export_type, '', true);
        }
        if ($export_type !== null) {
            $queryParams['exportType'] = $export_type;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/zip']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/zip'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourses
     *
     * Get a list of all courses for the specified tenant
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CourseListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCourses($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        list($response) = $this->getCoursesWithHttpInfo($engine_tenant_name, $more, $since, $until, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCoursesWithHttpInfo
     *
     * Get a list of all courses for the specified tenant
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CourseListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCoursesWithHttpInfo($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        $request = $this->getCoursesRequest($engine_tenant_name, $more, $since, $until, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\CourseListSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\CourseListSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\CourseListSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CourseListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCoursesAsync
     *
     * Get a list of all courses for the specified tenant
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCoursesAsync($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        return $this->getCoursesAsyncWithHttpInfo($engine_tenant_name, $more, $since, $until, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCoursesAsyncWithHttpInfo
     *
     * Get a list of all courses for the specified tenant
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCoursesAsyncWithHttpInfo($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseListSchema';
        $request = $this->getCoursesRequest($engine_tenant_name, $more, $since, $until, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourses'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCoursesRequest($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = false, $include_course_metadata = false)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourses'
            );
        }

        $resourcePath = '/courses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($more)) {
            $more = ObjectSerializer::serializeCollection($more, '', true);
        }
        if ($more !== null) {
            $queryParams['more'] = $more;
        }
        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($until)) {
            $until = ObjectSerializer::serializeCollection($until, '', true);
        }
        if ($until !== null) {
            $queryParams['until'] = $until;
        }
        // query params
        if (is_array($include_registration_count)) {
            $include_registration_count = ObjectSerializer::serializeCollection($include_registration_count, '', true);
        }
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = $include_registration_count;
        }
        // query params
        if (is_array($include_course_metadata)) {
            $include_course_metadata = ObjectSerializer::serializeCollection($include_course_metadata, '', true);
        }
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = $include_course_metadata;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImportJobStatus
     *
     * Check the status of an import job.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\ImportJobResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\ResponseErrorSchema
     */
    public function getImportJobStatus($engine_tenant_name, $import_job_id)
    {
        list($response) = $this->getImportJobStatusWithHttpInfo($engine_tenant_name, $import_job_id);
        return $response;
    }

    /**
     * Operation getImportJobStatusWithHttpInfo
     *
     * Check the status of an import job.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\ImportJobResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\ResponseErrorSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImportJobStatusWithHttpInfo($engine_tenant_name, $import_job_id)
    {
        $request = $this->getImportJobStatusRequest($engine_tenant_name, $import_job_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\ImportJobResultSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\ImportJobResultSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\ResponseErrorSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\ResponseErrorSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\ImportJobResultSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ImportJobResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ResponseErrorSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImportJobStatusAsync
     *
     * Check the status of an import job.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportJobStatusAsync($engine_tenant_name, $import_job_id)
    {
        return $this->getImportJobStatusAsyncWithHttpInfo($engine_tenant_name, $import_job_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImportJobStatusAsyncWithHttpInfo
     *
     * Check the status of an import job.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportJobStatusAsyncWithHttpInfo($engine_tenant_name, $import_job_id)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportJobResultSchema';
        $request = $this->getImportJobStatusRequest($engine_tenant_name, $import_job_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImportJobStatus'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getImportJobStatusRequest($engine_tenant_name, $import_job_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getImportJobStatus'
            );
        }
        // verify the required parameter 'import_job_id' is set
        if ($import_job_id === null || (is_array($import_job_id) && count($import_job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_job_id when calling getImportJobStatus'
            );
        }

        $resourcePath = '/courses/importJobs/{importJobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($import_job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'importJobId' . '}',
                ObjectSerializer::toPathValue($import_job_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVersionedCourseZip
     *
     * Get the zip package for the specified course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type export_type (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getVersionedCourseZip($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        list($response) = $this->getVersionedCourseZipWithHttpInfo($engine_tenant_name, $course_id, $version_id, $export_type);
        return $response;
    }

    /**
     * Operation getVersionedCourseZipWithHttpInfo
     *
     * Get the zip package for the specified course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVersionedCourseZipWithHttpInfo($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        $request = $this->getVersionedCourseZipRequest($engine_tenant_name, $course_id, $version_id, $export_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVersionedCourseZipAsync
     *
     * Get the zip package for the specified course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVersionedCourseZipAsync($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        return $this->getVersionedCourseZipAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $export_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVersionedCourseZipAsyncWithHttpInfo
     *
     * Get the zip package for the specified course version
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVersionedCourseZipAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        $returnType = '\SplFileObject';
        $request = $this->getVersionedCourseZipRequest($engine_tenant_name, $course_id, $version_id, $export_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVersionedCourseZip'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $export_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVersionedCourseZipRequest($engine_tenant_name, $course_id, $version_id, $export_type)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getVersionedCourseZip'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getVersionedCourseZip'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getVersionedCourseZip'
            );
        }
        // verify the required parameter 'export_type' is set
        if ($export_type === null || (is_array($export_type) && count($export_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_type when calling getVersionedCourseZip'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/zip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($export_type)) {
            $export_type = ObjectSerializer::serializeCollection($export_type, '', true);
        }
        if ($export_type !== null) {
            $queryParams['exportType'] = $export_type;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/zip']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/zip'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importCourseAssetFile
     *
     * Import an asset file for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\AssetFileSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function importCourseAssetFile($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        list($response) = $this->importCourseAssetFileWithHttpInfo($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy);
        return $response;
    }

    /**
     * Operation importCourseAssetFileWithHttpInfo
     *
     * Import an asset file for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\AssetFileSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function importCourseAssetFileWithHttpInfo($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        $request = $this->importCourseAssetFileRequest($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\AssetFileSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\AssetFileSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\AssetFileSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\AssetFileSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importCourseAssetFileAsync
     *
     * Import an asset file for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseAssetFileAsync($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        return $this->importCourseAssetFileAsyncWithHttpInfo($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importCourseAssetFileAsyncWithHttpInfo
     *
     * Import an asset file for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseAssetFileAsyncWithHttpInfo($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\AssetFileSchema';
        $request = $this->importCourseAssetFileRequest($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importCourseAssetFile'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importCourseAssetFileRequest($engine_tenant_name, $course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling importCourseAssetFile'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling importCourseAssetFile'
            );
        }
        // verify the required parameter 'asset_schema' is set
        if ($asset_schema === null || (is_array($asset_schema) && count($asset_schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_schema when calling importCourseAssetFile'
            );
        }

        $resourcePath = '/courses/{courseId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($update_asset_policy)) {
            $update_asset_policy = ObjectSerializer::serializeCollection($update_asset_policy, '', true);
        }
        if ($update_asset_policy !== null) {
            $queryParams['updateAssetPolicy'] = $update_asset_policy;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($asset_schema)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($asset_schema));
            } else {
                $httpBody = $asset_schema;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importCourseVersionAssetFile
     *
     * Import an asset file for this course version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\AssetFileSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function importCourseVersionAssetFile($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        list($response) = $this->importCourseVersionAssetFileWithHttpInfo($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy);
        return $response;
    }

    /**
     * Operation importCourseVersionAssetFileWithHttpInfo
     *
     * Import an asset file for this course version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\AssetFileSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function importCourseVersionAssetFileWithHttpInfo($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        $request = $this->importCourseVersionAssetFileRequest($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\AssetFileSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\AssetFileSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\AssetFileSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\AssetFileSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importCourseVersionAssetFileAsync
     *
     * Import an asset file for this course version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseVersionAssetFileAsync($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        return $this->importCourseVersionAssetFileAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importCourseVersionAssetFileAsyncWithHttpInfo
     *
     * Import an asset file for this course version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseVersionAssetFileAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\AssetFileSchema';
        $request = $this->importCourseVersionAssetFileRequest($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importCourseVersionAssetFile'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importCourseVersionAssetFileRequest($engine_tenant_name, $course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling importCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling importCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling importCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'asset_schema' is set
        if ($asset_schema === null || (is_array($asset_schema) && count($asset_schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_schema when calling importCourseVersionAssetFile'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($update_asset_policy)) {
            $update_asset_policy = ObjectSerializer::serializeCollection($update_asset_policy, '', true);
        }
        if ($update_asset_policy !== null) {
            $queryParams['updateAssetPolicy'] = $update_asset_policy;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($asset_schema)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($asset_schema));
            } else {
                $httpBody = $asset_schema;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importCourseWithoutUpload
     *
     * Create a course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\ImportResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function importCourseWithoutUpload($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false, $dry_run = false)
    {
        list($response) = $this->importCourseWithoutUploadWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version, $dry_run);
        return $response;
    }

    /**
     * Operation importCourseWithoutUploadWithHttpInfo
     *
     * Create a course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\ImportResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function importCourseWithoutUploadWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false, $dry_run = false)
    {
        $request = $this->importCourseWithoutUploadRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version, $dry_run);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\ImportResultSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\ImportResultSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\ImportResultSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ImportResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importCourseWithoutUploadAsync
     *
     * Create a course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseWithoutUploadAsync($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false, $dry_run = false)
    {
        return $this->importCourseWithoutUploadAsyncWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version, $dry_run)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importCourseWithoutUploadAsyncWithHttpInfo
     *
     * Create a course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseWithoutUploadAsyncWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false, $dry_run = false)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportResultSchema';
        $request = $this->importCourseWithoutUploadRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version, $dry_run);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importCourseWithoutUpload'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importCourseWithoutUploadRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version = false, $dry_run = false)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling importCourseWithoutUpload'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling importCourseWithoutUpload'
            );
        }
        // verify the required parameter 'import_request' is set
        if ($import_request === null || (is_array($import_request) && count($import_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_request when calling importCourseWithoutUpload'
            );
        }

        $resourcePath = '/courses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($course_id)) {
            $course_id = ObjectSerializer::serializeCollection($course_id, '', true);
        }
        if ($course_id !== null) {
            $queryParams['courseId'] = $course_id;
        }
        // query params
        if (is_array($may_create_new_version)) {
            $may_create_new_version = ObjectSerializer::serializeCollection($may_create_new_version, '', true);
        }
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = $may_create_new_version;
        }
        // query params
        if (is_array($dry_run)) {
            $dry_run = ObjectSerializer::serializeCollection($dry_run, '', true);
        }
        if ($dry_run !== null) {
            $queryParams['dryRun'] = $dry_run;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($import_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($import_request));
            } else {
                $httpBody = $import_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseConfiguration
     *
     * Set configuration settings for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseConfiguration($engine_tenant_name, $course_id, $configuration_settings)
    {
        $this->setCourseConfigurationWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings);
    }

    /**
     * Operation setCourseConfigurationWithHttpInfo
     *
     * Set configuration settings for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseConfigurationWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
    {
        $request = $this->setCourseConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseConfigurationAsync
     *
     * Set configuration settings for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseConfigurationAsync($engine_tenant_name, $course_id, $configuration_settings)
    {
        return $this->setCourseConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseConfigurationAsyncWithHttpInfo
     *
     * Set configuration settings for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setCourseConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setCourseConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($configuration_settings)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($configuration_settings));
            } else {
                $httpBody = $configuration_settings;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseTitle
     *
     * Sets the course title for &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title title (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseTitle($engine_tenant_name, $course_id, $title)
    {
        $this->setCourseTitleWithHttpInfo($engine_tenant_name, $course_id, $title);
    }

    /**
     * Operation setCourseTitleWithHttpInfo
     *
     * Sets the course title for &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseTitleWithHttpInfo($engine_tenant_name, $course_id, $title)
    {
        $request = $this->setCourseTitleRequest($engine_tenant_name, $course_id, $title);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseTitleAsync
     *
     * Sets the course title for &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseTitleAsync($engine_tenant_name, $course_id, $title)
    {
        return $this->setCourseTitleAsyncWithHttpInfo($engine_tenant_name, $course_id, $title)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseTitleAsyncWithHttpInfo
     *
     * Sets the course title for &#x60;courseId&#x60;
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseTitleAsyncWithHttpInfo($engine_tenant_name, $course_id, $title)
    {
        $returnType = '';
        $request = $this->setCourseTitleRequest($engine_tenant_name, $course_id, $title);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseTitle'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setCourseTitleRequest($engine_tenant_name, $course_id, $title)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setCourseTitle'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseTitle'
            );
        }
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling setCourseTitle'
            );
        }

        $resourcePath = '/courses/{courseId}/title';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($title)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($title));
            } else {
                $httpBody = $title;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseVersionConfiguration
     *
     * Set configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseVersionConfiguration($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        $this->setCourseVersionConfigurationWithHttpInfo($engine_tenant_name, $course_id, $version_id, $configuration_settings);
    }

    /**
     * Operation setCourseVersionConfigurationWithHttpInfo
     *
     * Set configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseVersionConfigurationWithHttpInfo($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        $request = $this->setCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseVersionConfigurationAsync
     *
     * Set configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionConfigurationAsync($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        return $this->setCourseVersionConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseVersionConfigurationAsyncWithHttpInfo
     *
     * Set configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseVersionConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseVersionConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($configuration_settings)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($configuration_settings));
            } else {
                $httpBody = $configuration_settings;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseVersionsConfiguration
     *
     * Set configuration settings for all versions of this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseVersionsConfiguration($engine_tenant_name, $course_id, $configuration_settings)
    {
        $this->setCourseVersionsConfigurationWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings);
    }

    /**
     * Operation setCourseVersionsConfigurationWithHttpInfo
     *
     * Set configuration settings for all versions of this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseVersionsConfigurationWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
    {
        $request = $this->setCourseVersionsConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseVersionsConfigurationAsync
     *
     * Set configuration settings for all versions of this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionsConfigurationAsync($engine_tenant_name, $course_id, $configuration_settings)
    {
        return $this->setCourseVersionsConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseVersionsConfigurationAsyncWithHttpInfo
     *
     * Set configuration settings for all versions of this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionsConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseVersionsConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseVersionsConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setCourseVersionsConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setCourseVersionsConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseVersionsConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseVersionsConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($configuration_settings)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($configuration_settings));
            } else {
                $httpBody = $configuration_settings;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadAndImportCourse
     *
     * Upload a course to import
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\ImportResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function uploadAndImportCourse($engine_tenant_name, $course_id, $may_create_new_version = false, $dry_run = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        list($response) = $this->uploadAndImportCourseWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version, $dry_run, $uploaded_content_type, $file, $content_metadata);
        return $response;
    }

    /**
     * Operation uploadAndImportCourseWithHttpInfo
     *
     * Upload a course to import
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\ImportResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadAndImportCourseWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version = false, $dry_run = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        $request = $this->uploadAndImportCourseRequest($engine_tenant_name, $course_id, $may_create_new_version, $dry_run, $uploaded_content_type, $file, $content_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\ImportResultSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\ImportResultSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\ImportResultSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ImportResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadAndImportCourseAsync
     *
     * Upload a course to import
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAndImportCourseAsync($engine_tenant_name, $course_id, $may_create_new_version = false, $dry_run = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        return $this->uploadAndImportCourseAsyncWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version, $dry_run, $uploaded_content_type, $file, $content_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadAndImportCourseAsyncWithHttpInfo
     *
     * Upload a course to import
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAndImportCourseAsyncWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version = false, $dry_run = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportResultSchema';
        $request = $this->uploadAndImportCourseRequest($engine_tenant_name, $course_id, $may_create_new_version, $dry_run, $uploaded_content_type, $file, $content_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadAndImportCourse'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to 'application/zip')
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadAndImportCourseRequest($engine_tenant_name, $course_id, $may_create_new_version = false, $dry_run = false, $uploaded_content_type = 'application/zip', $file = null, $content_metadata = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling uploadAndImportCourse'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling uploadAndImportCourse'
            );
        }

        $resourcePath = '/courses/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($course_id)) {
            $course_id = ObjectSerializer::serializeCollection($course_id, '', true);
        }
        if ($course_id !== null) {
            $queryParams['courseId'] = $course_id;
        }
        // query params
        if (is_array($may_create_new_version)) {
            $may_create_new_version = ObjectSerializer::serializeCollection($may_create_new_version, '', true);
        }
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = $may_create_new_version;
        }
        // query params
        if (is_array($dry_run)) {
            $dry_run = ObjectSerializer::serializeCollection($dry_run, '', true);
        }
        if ($dry_run !== null) {
            $queryParams['dryRun'] = $dry_run;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }
        // header params
        if ($uploaded_content_type !== null) {
            $headerParams['uploadedContentType'] = ObjectSerializer::toHeaderValue($uploaded_content_type);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($content_metadata !== null) {
            $formParams['contentMetadata'] = ObjectSerializer::toFormValue($content_metadata);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadCourseAssetFile
     *
     * Upload an asset file for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\AssetFileSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function uploadCourseAssetFile($engine_tenant_name, $course_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        list($response) = $this->uploadCourseAssetFileWithHttpInfo($engine_tenant_name, $course_id, $destination, $update_asset_policy, $file);
        return $response;
    }

    /**
     * Operation uploadCourseAssetFileWithHttpInfo
     *
     * Upload an asset file for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\AssetFileSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadCourseAssetFileWithHttpInfo($engine_tenant_name, $course_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        $request = $this->uploadCourseAssetFileRequest($engine_tenant_name, $course_id, $destination, $update_asset_policy, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\AssetFileSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\AssetFileSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\AssetFileSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\AssetFileSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadCourseAssetFileAsync
     *
     * Upload an asset file for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCourseAssetFileAsync($engine_tenant_name, $course_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        return $this->uploadCourseAssetFileAsyncWithHttpInfo($engine_tenant_name, $course_id, $destination, $update_asset_policy, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadCourseAssetFileAsyncWithHttpInfo
     *
     * Upload an asset file for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCourseAssetFileAsyncWithHttpInfo($engine_tenant_name, $course_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\AssetFileSchema';
        $request = $this->uploadCourseAssetFileRequest($engine_tenant_name, $course_id, $destination, $update_asset_policy, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadCourseAssetFile'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadCourseAssetFileRequest($engine_tenant_name, $course_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling uploadCourseAssetFile'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling uploadCourseAssetFile'
            );
        }
        // verify the required parameter 'destination' is set
        if ($destination === null || (is_array($destination) && count($destination) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destination when calling uploadCourseAssetFile'
            );
        }

        $resourcePath = '/courses/{courseId}/asset/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($update_asset_policy)) {
            $update_asset_policy = ObjectSerializer::serializeCollection($update_asset_policy, '', true);
        }
        if ($update_asset_policy !== null) {
            $queryParams['updateAssetPolicy'] = $update_asset_policy;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($destination !== null) {
            $formParams['destination'] = ObjectSerializer::toFormValue($destination);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadCourseVersionAssetFile
     *
     * Upload an asset file for this course version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\AssetFileSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function uploadCourseVersionAssetFile($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        list($response) = $this->uploadCourseVersionAssetFileWithHttpInfo($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy, $file);
        return $response;
    }

    /**
     * Operation uploadCourseVersionAssetFileWithHttpInfo
     *
     * Upload an asset file for this course version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\AssetFileSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadCourseVersionAssetFileWithHttpInfo($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        $request = $this->uploadCourseVersionAssetFileRequest($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RusticiSoftware\Engine\V2\Model\AssetFileSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\AssetFileSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\RusticiSoftware\Engine\V2\Model\MessageSchema' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RusticiSoftware\Engine\V2\Model\MessageSchema', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RusticiSoftware\Engine\V2\Model\AssetFileSchema';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\AssetFileSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadCourseVersionAssetFileAsync
     *
     * Upload an asset file for this course version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCourseVersionAssetFileAsync($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        return $this->uploadCourseVersionAssetFileAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadCourseVersionAssetFileAsyncWithHttpInfo
     *
     * Upload an asset file for this course version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCourseVersionAssetFileAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\AssetFileSchema';
        $request = $this->uploadCourseVersionAssetFileRequest($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadCourseVersionAssetFile'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $destination Path, relative to the course&#39;s Content Directory, that indicates where to store the uploaded asset file. (required)
     * @param  string $update_asset_policy Describes how Engine should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to 'lax')
     * @param  \SplFileObject $file The course content file to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadCourseVersionAssetFileRequest($engine_tenant_name, $course_id, $version_id, $destination, $update_asset_policy = 'lax', $file = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling uploadCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling uploadCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling uploadCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'destination' is set
        if ($destination === null || (is_array($destination) && count($destination) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destination when calling uploadCourseVersionAssetFile'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($update_asset_policy)) {
            $update_asset_policy = ObjectSerializer::serializeCollection($update_asset_policy, '', true);
        }
        if ($update_asset_policy !== null) {
            $queryParams['updateAssetPolicy'] = $update_asset_policy;
        }

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($destination !== null) {
            $formParams['destination'] = ObjectSerializer::toFormValue($destination);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

<?php
/**
 * AppManagementApi
 * PHP version 8.1
 *
 * @category Class
 * @package  RusticiSoftware\Engine\V2
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Rustici Engine API
 *
 * Rustici Engine API
 *
 * The version of the OpenAPI document: 2.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.18.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace RusticiSoftware\Engine\V2\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use RusticiSoftware\Engine\V2\ApiException;
use RusticiSoftware\Engine\V2\Configuration;
use RusticiSoftware\Engine\V2\FormDataProcessor;
use RusticiSoftware\Engine\V2\HeaderSelector;
use RusticiSoftware\Engine\V2\ObjectSerializer;

/**
 * AppManagementApi Class Doc Comment
 *
 * @category Class
 * @package  RusticiSoftware\Engine\V2
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AppManagementApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createCredential' => [
            'application/json',
        ],
        'createOrUpdateTenant' => [
            'application/json',
        ],
        'createSubscription' => [
            'application/json',
        ],
        'createSubscriptionAuth' => [
            'application/json',
        ],
        'createToken' => [
            'application/json',
        ],
        'deleteApplicationConfigurationSetting' => [
            'application/json',
        ],
        'deleteCredential' => [
            'application/json',
        ],
        'deleteSubscription' => [
            'application/json',
        ],
        'deleteSubscriptionAuth' => [
            'application/json',
        ],
        'deleteTenant' => [
            'application/json',
        ],
        'deleteTenantData' => [
            'application/json',
        ],
        'getApplicationConfiguration' => [
            'application/json',
        ],
        'getAuthenticatedCredential' => [
            'application/json',
        ],
        'getCredential' => [
            'application/json',
        ],
        'getCredentials' => [
            'application/json',
        ],
        'getPIIDeletionJob' => [
            'application/json',
        ],
        'getSubscription' => [
            'application/json',
        ],
        'getSubscriptionAuth' => [
            'application/json',
        ],
        'getSubscriptionAuths' => [
            'application/json',
        ],
        'getSubscriptions' => [
            'application/json',
        ],
        'getTenantList' => [
            'application/json',
        ],
        'inspectToken' => [
            'application/json',
        ],
        'postPIIDeletionJob' => [
            'application/json',
        ],
        'postUpdateEncryptedSetting' => [
            'application/json',
        ],
        'resetCredentialSecret' => [
            'application/json',
        ],
        'setApplicationConfiguration' => [
            'application/json',
        ],
        'updateCredential' => [
            'application/json',
        ],
        'updateSubscription' => [
            'application/json',
        ],
        'updateSubscriptionAuth' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createCredential
     *
     * Create credential
     *
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_request credential_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CredentialCreatedSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function createCredential($credential_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createCredential'][0])
    {
        list($response) = $this->createCredentialWithHttpInfo($credential_request, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation createCredentialWithHttpInfo
     *
     * Create credential
     *
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CredentialCreatedSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCredentialWithHttpInfo($credential_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createCredential'][0])
    {
        $request = $this->createCredentialRequest($credential_request, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\CredentialCreatedSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\CredentialCreatedSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CredentialCreatedSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCredentialAsync
     *
     * Create credential
     *
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCredentialAsync($credential_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createCredential'][0])
    {
        return $this->createCredentialAsyncWithHttpInfo($credential_request, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCredentialAsyncWithHttpInfo
     *
     * Create credential
     *
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCredentialAsyncWithHttpInfo($credential_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createCredential'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CredentialCreatedSchema';
        $request = $this->createCredentialRequest($credential_request, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCredential'
     *
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCredentialRequest($credential_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createCredential'][0])
    {

        // verify the required parameter 'credential_request' is set
        if ($credential_request === null || (is_array($credential_request) && count($credential_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_request when calling createCredential'
            );
        }



        $resourcePath = '/appManagement/credentials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($credential_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($credential_request));
            } else {
                $httpBody = $credential_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrUpdateTenant
     *
     * Create or update tenant
     *
     * @param  string $tenant_name tenant_name (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TenantProperties $tenant_properties tenant_properties (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrUpdateTenant'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createOrUpdateTenant($tenant_name, $tenant_properties, string $contentType = self::contentTypes['createOrUpdateTenant'][0])
    {
        $this->createOrUpdateTenantWithHttpInfo($tenant_name, $tenant_properties, $contentType);
    }

    /**
     * Operation createOrUpdateTenantWithHttpInfo
     *
     * Create or update tenant
     *
     * @param  string $tenant_name (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TenantProperties $tenant_properties (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrUpdateTenant'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrUpdateTenantWithHttpInfo($tenant_name, $tenant_properties, string $contentType = self::contentTypes['createOrUpdateTenant'][0])
    {
        $request = $this->createOrUpdateTenantRequest($tenant_name, $tenant_properties, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createOrUpdateTenantAsync
     *
     * Create or update tenant
     *
     * @param  string $tenant_name (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TenantProperties $tenant_properties (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrUpdateTenant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrUpdateTenantAsync($tenant_name, $tenant_properties, string $contentType = self::contentTypes['createOrUpdateTenant'][0])
    {
        return $this->createOrUpdateTenantAsyncWithHttpInfo($tenant_name, $tenant_properties, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrUpdateTenantAsyncWithHttpInfo
     *
     * Create or update tenant
     *
     * @param  string $tenant_name (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TenantProperties $tenant_properties (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrUpdateTenant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrUpdateTenantAsyncWithHttpInfo($tenant_name, $tenant_properties, string $contentType = self::contentTypes['createOrUpdateTenant'][0])
    {
        $returnType = '';
        $request = $this->createOrUpdateTenantRequest($tenant_name, $tenant_properties, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrUpdateTenant'
     *
     * @param  string $tenant_name (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TenantProperties $tenant_properties (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrUpdateTenant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrUpdateTenantRequest($tenant_name, $tenant_properties, string $contentType = self::contentTypes['createOrUpdateTenant'][0])
    {

        // verify the required parameter 'tenant_name' is set
        if ($tenant_name === null || (is_array($tenant_name) && count($tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_name when calling createOrUpdateTenant'
            );
        }

        // verify the required parameter 'tenant_properties' is set
        if ($tenant_properties === null || (is_array($tenant_properties) && count($tenant_properties) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_properties when calling createOrUpdateTenant'
            );
        }


        $resourcePath = '/appManagement/tenants/{tenantName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tenant_name !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantName' . '}',
                ObjectSerializer::toPathValue($tenant_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tenant_properties)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tenant_properties));
            } else {
                $httpBody = $tenant_properties;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSubscription
     *
     * Create subscription
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function createSubscription($subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscription'][0])
    {
        list($response) = $this->createSubscriptionWithHttpInfo($subscription_definition, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation createSubscriptionWithHttpInfo
     *
     * Create subscription
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSubscriptionWithHttpInfo($subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscription'][0])
    {
        $request = $this->createSubscriptionRequest($subscription_definition, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createSubscriptionAsync
     *
     * Create subscription
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubscriptionAsync($subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscription'][0])
    {
        return $this->createSubscriptionAsyncWithHttpInfo($subscription_definition, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSubscriptionAsyncWithHttpInfo
     *
     * Create subscription
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubscriptionAsyncWithHttpInfo($subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscription'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createSubscriptionRequest($subscription_definition, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSubscription'
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSubscriptionRequest($subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscription'][0])
    {

        // verify the required parameter 'subscription_definition' is set
        if ($subscription_definition === null || (is_array($subscription_definition) && count($subscription_definition) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_definition when calling createSubscription'
            );
        }



        $resourcePath = '/appManagement/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_definition)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_definition));
            } else {
                $httpBody = $subscription_definition;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSubscriptionAuth
     *
     * Create subscription authentication configurations
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function createSubscriptionAuth($subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscriptionAuth'][0])
    {
        list($response) = $this->createSubscriptionAuthWithHttpInfo($subscription_auth_definition, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation createSubscriptionAuthWithHttpInfo
     *
     * Create subscription authentication configurations
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSubscriptionAuthWithHttpInfo($subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscriptionAuth'][0])
    {
        $request = $this->createSubscriptionAuthRequest($subscription_auth_definition, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createSubscriptionAuthAsync
     *
     * Create subscription authentication configurations
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubscriptionAuthAsync($subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscriptionAuth'][0])
    {
        return $this->createSubscriptionAuthAsyncWithHttpInfo($subscription_auth_definition, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSubscriptionAuthAsyncWithHttpInfo
     *
     * Create subscription authentication configurations
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubscriptionAuthAsyncWithHttpInfo($subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscriptionAuth'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createSubscriptionAuthRequest($subscription_auth_definition, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSubscriptionAuth'
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSubscriptionAuthRequest($subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['createSubscriptionAuth'][0])
    {

        // verify the required parameter 'subscription_auth_definition' is set
        if ($subscription_auth_definition === null || (is_array($subscription_auth_definition) && count($subscription_auth_definition) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_auth_definition when calling createSubscriptionAuth'
            );
        }



        $resourcePath = '/appManagement/subscriptions/authConfigurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_auth_definition)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_auth_definition));
            } else {
                $httpBody = $subscription_auth_definition;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createToken
     *
     * Create token
     *
     * @param  \RusticiSoftware\Engine\V2\Model\TokenRequestSchema $token_request token_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createToken'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function createToken($token_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createToken'][0])
    {
        list($response) = $this->createTokenWithHttpInfo($token_request, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation createTokenWithHttpInfo
     *
     * Create token
     *
     * @param  \RusticiSoftware\Engine\V2\Model\TokenRequestSchema $token_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createToken'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTokenWithHttpInfo($token_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createToken'][0])
    {
        $request = $this->createTokenRequest($token_request, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTokenAsync
     *
     * Create token
     *
     * @param  \RusticiSoftware\Engine\V2\Model\TokenRequestSchema $token_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTokenAsync($token_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createToken'][0])
    {
        return $this->createTokenAsyncWithHttpInfo($token_request, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTokenAsyncWithHttpInfo
     *
     * Create token
     *
     * @param  \RusticiSoftware\Engine\V2\Model\TokenRequestSchema $token_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTokenAsyncWithHttpInfo($token_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createToken'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createTokenRequest($token_request, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createToken'
     *
     * @param  \RusticiSoftware\Engine\V2\Model\TokenRequestSchema $token_request (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTokenRequest($token_request, $engine_tenant_name = null, string $contentType = self::contentTypes['createToken'][0])
    {

        // verify the required parameter 'token_request' is set
        if ($token_request === null || (is_array($token_request) && count($token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_request when calling createToken'
            );
        }



        $resourcePath = '/appManagement/token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($token_request));
            } else {
                $httpBody = $token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteApplicationConfigurationSetting
     *
     * Clears the &#x60;settingId&#x60; value for this level
     *
     * @param  string $setting_id setting_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationConfigurationSetting'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteApplicationConfigurationSetting($setting_id, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['deleteApplicationConfigurationSetting'][0])
    {
        $this->deleteApplicationConfigurationSettingWithHttpInfo($setting_id, $engine_tenant_name, $learning_standard, $single_sco, $contentType);
    }

    /**
     * Operation deleteApplicationConfigurationSettingWithHttpInfo
     *
     * Clears the &#x60;settingId&#x60; value for this level
     *
     * @param  string $setting_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationConfigurationSetting'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteApplicationConfigurationSettingWithHttpInfo($setting_id, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['deleteApplicationConfigurationSetting'][0])
    {
        $request = $this->deleteApplicationConfigurationSettingRequest($setting_id, $engine_tenant_name, $learning_standard, $single_sco, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteApplicationConfigurationSettingAsync
     *
     * Clears the &#x60;settingId&#x60; value for this level
     *
     * @param  string $setting_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationConfigurationSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteApplicationConfigurationSettingAsync($setting_id, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['deleteApplicationConfigurationSetting'][0])
    {
        return $this->deleteApplicationConfigurationSettingAsyncWithHttpInfo($setting_id, $engine_tenant_name, $learning_standard, $single_sco, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteApplicationConfigurationSettingAsyncWithHttpInfo
     *
     * Clears the &#x60;settingId&#x60; value for this level
     *
     * @param  string $setting_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationConfigurationSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteApplicationConfigurationSettingAsyncWithHttpInfo($setting_id, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['deleteApplicationConfigurationSetting'][0])
    {
        $returnType = '';
        $request = $this->deleteApplicationConfigurationSettingRequest($setting_id, $engine_tenant_name, $learning_standard, $single_sco, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteApplicationConfigurationSetting'
     *
     * @param  string $setting_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationConfigurationSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteApplicationConfigurationSettingRequest($setting_id, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['deleteApplicationConfigurationSetting'][0])
    {

        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteApplicationConfigurationSetting'
            );
        }





        $resourcePath = '/appManagement/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $learning_standard,
            'learningStandard', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single_sco,
            'singleSco', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCredential
     *
     * Removes &#x60;credentialId&#x60; credentials
     *
     * @param  string $credential_id credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCredential($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteCredential'][0])
    {
        $this->deleteCredentialWithHttpInfo($credential_id, $engine_tenant_name, $contentType);
    }

    /**
     * Operation deleteCredentialWithHttpInfo
     *
     * Removes &#x60;credentialId&#x60; credentials
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCredentialWithHttpInfo($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteCredential'][0])
    {
        $request = $this->deleteCredentialRequest($credential_id, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteCredentialAsync
     *
     * Removes &#x60;credentialId&#x60; credentials
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCredentialAsync($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteCredential'][0])
    {
        return $this->deleteCredentialAsyncWithHttpInfo($credential_id, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCredentialAsyncWithHttpInfo
     *
     * Removes &#x60;credentialId&#x60; credentials
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCredentialAsyncWithHttpInfo($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteCredential'][0])
    {
        $returnType = '';
        $request = $this->deleteCredentialRequest($credential_id, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCredential'
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCredentialRequest($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteCredential'][0])
    {

        // verify the required parameter 'credential_id' is set
        if ($credential_id === null || (is_array($credential_id) && count($credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_id when calling deleteCredential'
            );
        }



        $resourcePath = '/appManagement/credentials/{credentialId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialId' . '}',
                ObjectSerializer::toPathValue($credential_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSubscription
     *
     * Delete subscription
     *
     * @param  string $subscription_id subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscription'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSubscription($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscription'][0])
    {
        $this->deleteSubscriptionWithHttpInfo($subscription_id, $engine_tenant_name, $contentType);
    }

    /**
     * Operation deleteSubscriptionWithHttpInfo
     *
     * Delete subscription
     *
     * @param  string $subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscription'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSubscriptionWithHttpInfo($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscription'][0])
    {
        $request = $this->deleteSubscriptionRequest($subscription_id, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteSubscriptionAsync
     *
     * Delete subscription
     *
     * @param  string $subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSubscriptionAsync($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscription'][0])
    {
        return $this->deleteSubscriptionAsyncWithHttpInfo($subscription_id, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSubscriptionAsyncWithHttpInfo
     *
     * Delete subscription
     *
     * @param  string $subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSubscriptionAsyncWithHttpInfo($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscription'][0])
    {
        $returnType = '';
        $request = $this->deleteSubscriptionRequest($subscription_id, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSubscription'
     *
     * @param  string $subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSubscriptionRequest($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscription'][0])
    {

        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null || (is_array($subscription_id) && count($subscription_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_id when calling deleteSubscription'
            );
        }



        $resourcePath = '/appManagement/subscriptions/{subscriptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriptionId' . '}',
                ObjectSerializer::toPathValue($subscription_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSubscriptionAuth
     *
     * Delete subscription authentication configuration. Any subscription using this authentication configuration will be disabled.
     *
     * @param  string $subscription_auth_id subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSubscriptionAuth($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscriptionAuth'][0])
    {
        $this->deleteSubscriptionAuthWithHttpInfo($subscription_auth_id, $engine_tenant_name, $contentType);
    }

    /**
     * Operation deleteSubscriptionAuthWithHttpInfo
     *
     * Delete subscription authentication configuration. Any subscription using this authentication configuration will be disabled.
     *
     * @param  string $subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSubscriptionAuthWithHttpInfo($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscriptionAuth'][0])
    {
        $request = $this->deleteSubscriptionAuthRequest($subscription_auth_id, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteSubscriptionAuthAsync
     *
     * Delete subscription authentication configuration. Any subscription using this authentication configuration will be disabled.
     *
     * @param  string $subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSubscriptionAuthAsync($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscriptionAuth'][0])
    {
        return $this->deleteSubscriptionAuthAsyncWithHttpInfo($subscription_auth_id, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSubscriptionAuthAsyncWithHttpInfo
     *
     * Delete subscription authentication configuration. Any subscription using this authentication configuration will be disabled.
     *
     * @param  string $subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSubscriptionAuthAsyncWithHttpInfo($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscriptionAuth'][0])
    {
        $returnType = '';
        $request = $this->deleteSubscriptionAuthRequest($subscription_auth_id, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSubscriptionAuth'
     *
     * @param  string $subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSubscriptionAuthRequest($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['deleteSubscriptionAuth'][0])
    {

        // verify the required parameter 'subscription_auth_id' is set
        if ($subscription_auth_id === null || (is_array($subscription_auth_id) && count($subscription_auth_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_auth_id when calling deleteSubscriptionAuth'
            );
        }



        $resourcePath = '/appManagement/subscriptions/authConfigurations/{subscriptionAuthId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($subscription_auth_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriptionAuthId' . '}',
                ObjectSerializer::toPathValue($subscription_auth_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTenant
     *
     * Delete a tenant. Warning: If tenant data is not deleted first, this will leave orphaned rows that can only be deleted manually. Does not remove any data, but does remove mapping between name and key used to store data. Consider deactivating instead.
     *
     * @param  string $tenant_name tenant_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenant'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTenant($tenant_name, string $contentType = self::contentTypes['deleteTenant'][0])
    {
        $this->deleteTenantWithHttpInfo($tenant_name, $contentType);
    }

    /**
     * Operation deleteTenantWithHttpInfo
     *
     * Delete a tenant. Warning: If tenant data is not deleted first, this will leave orphaned rows that can only be deleted manually. Does not remove any data, but does remove mapping between name and key used to store data. Consider deactivating instead.
     *
     * @param  string $tenant_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenant'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTenantWithHttpInfo($tenant_name, string $contentType = self::contentTypes['deleteTenant'][0])
    {
        $request = $this->deleteTenantRequest($tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTenantAsync
     *
     * Delete a tenant. Warning: If tenant data is not deleted first, this will leave orphaned rows that can only be deleted manually. Does not remove any data, but does remove mapping between name and key used to store data. Consider deactivating instead.
     *
     * @param  string $tenant_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTenantAsync($tenant_name, string $contentType = self::contentTypes['deleteTenant'][0])
    {
        return $this->deleteTenantAsyncWithHttpInfo($tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTenantAsyncWithHttpInfo
     *
     * Delete a tenant. Warning: If tenant data is not deleted first, this will leave orphaned rows that can only be deleted manually. Does not remove any data, but does remove mapping between name and key used to store data. Consider deactivating instead.
     *
     * @param  string $tenant_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTenantAsyncWithHttpInfo($tenant_name, string $contentType = self::contentTypes['deleteTenant'][0])
    {
        $returnType = '';
        $request = $this->deleteTenantRequest($tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTenant'
     *
     * @param  string $tenant_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTenantRequest($tenant_name, string $contentType = self::contentTypes['deleteTenant'][0])
    {

        // verify the required parameter 'tenant_name' is set
        if ($tenant_name === null || (is_array($tenant_name) && count($tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_name when calling deleteTenant'
            );
        }


        $resourcePath = '/appManagement/tenants/{tenantName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tenant_name !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantName' . '}',
                ObjectSerializer::toPathValue($tenant_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTenantData
     *
     * Delete all of a tenant&#39;s data.
     *
     * @param  string $tenant_name tenant_name (required)
     * @param  bool|null $system_schema_only Deletes tenant data from the system schema only. This does not remove the mapping between the tenant name and key. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenantData'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTenantData($tenant_name, $system_schema_only = false, string $contentType = self::contentTypes['deleteTenantData'][0])
    {
        $this->deleteTenantDataWithHttpInfo($tenant_name, $system_schema_only, $contentType);
    }

    /**
     * Operation deleteTenantDataWithHttpInfo
     *
     * Delete all of a tenant&#39;s data.
     *
     * @param  string $tenant_name (required)
     * @param  bool|null $system_schema_only Deletes tenant data from the system schema only. This does not remove the mapping between the tenant name and key. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenantData'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTenantDataWithHttpInfo($tenant_name, $system_schema_only = false, string $contentType = self::contentTypes['deleteTenantData'][0])
    {
        $request = $this->deleteTenantDataRequest($tenant_name, $system_schema_only, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTenantDataAsync
     *
     * Delete all of a tenant&#39;s data.
     *
     * @param  string $tenant_name (required)
     * @param  bool|null $system_schema_only Deletes tenant data from the system schema only. This does not remove the mapping between the tenant name and key. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenantData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTenantDataAsync($tenant_name, $system_schema_only = false, string $contentType = self::contentTypes['deleteTenantData'][0])
    {
        return $this->deleteTenantDataAsyncWithHttpInfo($tenant_name, $system_schema_only, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTenantDataAsyncWithHttpInfo
     *
     * Delete all of a tenant&#39;s data.
     *
     * @param  string $tenant_name (required)
     * @param  bool|null $system_schema_only Deletes tenant data from the system schema only. This does not remove the mapping between the tenant name and key. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenantData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTenantDataAsyncWithHttpInfo($tenant_name, $system_schema_only = false, string $contentType = self::contentTypes['deleteTenantData'][0])
    {
        $returnType = '';
        $request = $this->deleteTenantDataRequest($tenant_name, $system_schema_only, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTenantData'
     *
     * @param  string $tenant_name (required)
     * @param  bool|null $system_schema_only Deletes tenant data from the system schema only. This does not remove the mapping between the tenant name and key. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTenantData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTenantDataRequest($tenant_name, $system_schema_only = false, string $contentType = self::contentTypes['deleteTenantData'][0])
    {

        // verify the required parameter 'tenant_name' is set
        if ($tenant_name === null || (is_array($tenant_name) && count($tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_name when calling deleteTenantData'
            );
        }



        $resourcePath = '/appManagement/tenants/{tenantName}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $system_schema_only,
            'systemSchemaOnly', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($tenant_name !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantName' . '}',
                ObjectSerializer::toPathValue($tenant_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationConfiguration
     *
     * Returns all configuration settings for this level
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  bool|null $include_metadata include_metadata (optional, default to false)
     * @param  bool|null $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool|null $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool|null $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SettingListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getApplicationConfiguration($engine_tenant_name = null, $learning_standard = null, $single_sco = null, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true, string $contentType = self::contentTypes['getApplicationConfiguration'][0])
    {
        list($response) = $this->getApplicationConfigurationWithHttpInfo($engine_tenant_name, $learning_standard, $single_sco, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens, $contentType);
        return $response;
    }

    /**
     * Operation getApplicationConfigurationWithHttpInfo
     *
     * Returns all configuration settings for this level
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  bool|null $include_metadata (optional, default to false)
     * @param  bool|null $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool|null $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool|null $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SettingListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationConfigurationWithHttpInfo($engine_tenant_name = null, $learning_standard = null, $single_sco = null, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true, string $contentType = self::contentTypes['getApplicationConfiguration'][0])
    {
        $request = $this->getApplicationConfigurationRequest($engine_tenant_name, $learning_standard, $single_sco, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getApplicationConfigurationAsync
     *
     * Returns all configuration settings for this level
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  bool|null $include_metadata (optional, default to false)
     * @param  bool|null $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool|null $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool|null $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationConfigurationAsync($engine_tenant_name = null, $learning_standard = null, $single_sco = null, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true, string $contentType = self::contentTypes['getApplicationConfiguration'][0])
    {
        return $this->getApplicationConfigurationAsyncWithHttpInfo($engine_tenant_name, $learning_standard, $single_sco, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationConfigurationAsyncWithHttpInfo
     *
     * Returns all configuration settings for this level
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  bool|null $include_metadata (optional, default to false)
     * @param  bool|null $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool|null $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool|null $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationConfigurationAsyncWithHttpInfo($engine_tenant_name = null, $learning_standard = null, $single_sco = null, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true, string $contentType = self::contentTypes['getApplicationConfiguration'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getApplicationConfigurationRequest($engine_tenant_name, $learning_standard, $single_sco, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationConfiguration'
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  bool|null $include_metadata (optional, default to false)
     * @param  bool|null $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool|null $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool|null $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApplicationConfigurationRequest($engine_tenant_name = null, $learning_standard = null, $single_sco = null, $include_metadata = false, $include_hidden_settings = false, $include_secret_settings = false, $process_replacement_tokens = true, string $contentType = self::contentTypes['getApplicationConfiguration'][0])
    {









        $resourcePath = '/appManagement/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $learning_standard,
            'learningStandard', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single_sco,
            'singleSco', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_metadata,
            'includeMetadata', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_hidden_settings,
            'includeHiddenSettings', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_secret_settings,
            'includeSecretSettings', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $process_replacement_tokens,
            'processReplacementTokens', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAuthenticatedCredential
     *
     * Get information about the credential used to authenticate this request.
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAuthenticatedCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CredentialSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getAuthenticatedCredential($engine_tenant_name = null, string $contentType = self::contentTypes['getAuthenticatedCredential'][0])
    {
        list($response) = $this->getAuthenticatedCredentialWithHttpInfo($engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation getAuthenticatedCredentialWithHttpInfo
     *
     * Get information about the credential used to authenticate this request.
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAuthenticatedCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CredentialSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAuthenticatedCredentialWithHttpInfo($engine_tenant_name = null, string $contentType = self::contentTypes['getAuthenticatedCredential'][0])
    {
        $request = $this->getAuthenticatedCredentialRequest($engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\CredentialSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\CredentialSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CredentialSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAuthenticatedCredentialAsync
     *
     * Get information about the credential used to authenticate this request.
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAuthenticatedCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAuthenticatedCredentialAsync($engine_tenant_name = null, string $contentType = self::contentTypes['getAuthenticatedCredential'][0])
    {
        return $this->getAuthenticatedCredentialAsyncWithHttpInfo($engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAuthenticatedCredentialAsyncWithHttpInfo
     *
     * Get information about the credential used to authenticate this request.
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAuthenticatedCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAuthenticatedCredentialAsyncWithHttpInfo($engine_tenant_name = null, string $contentType = self::contentTypes['getAuthenticatedCredential'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CredentialSchema';
        $request = $this->getAuthenticatedCredentialRequest($engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAuthenticatedCredential'
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAuthenticatedCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAuthenticatedCredentialRequest($engine_tenant_name = null, string $contentType = self::contentTypes['getAuthenticatedCredential'][0])
    {



        $resourcePath = '/appManagement/authenticatedCredential';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCredential
     *
     * Get information on &#x60;credentialId&#x60; credential
     *
     * @param  string $credential_id credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CredentialSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCredential($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getCredential'][0])
    {
        list($response) = $this->getCredentialWithHttpInfo($credential_id, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation getCredentialWithHttpInfo
     *
     * Get information on &#x60;credentialId&#x60; credential
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CredentialSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCredentialWithHttpInfo($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getCredential'][0])
    {
        $request = $this->getCredentialRequest($credential_id, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\CredentialSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\CredentialSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CredentialSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCredentialAsync
     *
     * Get information on &#x60;credentialId&#x60; credential
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCredentialAsync($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getCredential'][0])
    {
        return $this->getCredentialAsyncWithHttpInfo($credential_id, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCredentialAsyncWithHttpInfo
     *
     * Get information on &#x60;credentialId&#x60; credential
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCredentialAsyncWithHttpInfo($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getCredential'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CredentialSchema';
        $request = $this->getCredentialRequest($credential_id, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCredential'
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCredentialRequest($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getCredential'][0])
    {

        // verify the required parameter 'credential_id' is set
        if ($credential_id === null || (is_array($credential_id) && count($credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_id when calling getCredential'
            );
        }



        $resourcePath = '/appManagement/credentials/{credentialId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialId' . '}',
                ObjectSerializer::toPathValue($credential_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCredentials
     *
     * List of credentials
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredentials'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CredentialSchema[]|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getCredentials($engine_tenant_name = null, string $contentType = self::contentTypes['getCredentials'][0])
    {
        list($response) = $this->getCredentialsWithHttpInfo($engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation getCredentialsWithHttpInfo
     *
     * List of credentials
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredentials'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CredentialSchema[]|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCredentialsWithHttpInfo($engine_tenant_name = null, string $contentType = self::contentTypes['getCredentials'][0])
    {
        $request = $this->getCredentialsRequest($engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\CredentialSchema[]',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\CredentialSchema[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CredentialSchema[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCredentialsAsync
     *
     * List of credentials
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCredentialsAsync($engine_tenant_name = null, string $contentType = self::contentTypes['getCredentials'][0])
    {
        return $this->getCredentialsAsyncWithHttpInfo($engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCredentialsAsyncWithHttpInfo
     *
     * List of credentials
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCredentialsAsyncWithHttpInfo($engine_tenant_name = null, string $contentType = self::contentTypes['getCredentials'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CredentialSchema[]';
        $request = $this->getCredentialsRequest($engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCredentials'
     *
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCredentialsRequest($engine_tenant_name = null, string $contentType = self::contentTypes['getCredentials'][0])
    {



        $resourcePath = '/appManagement/credentials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPIIDeletionJob
     *
     * Check the status of a PII deletion job with the provided job id.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $job_id job_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\PIIDeletionResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getPIIDeletionJob($engine_tenant_name, $job_id, string $contentType = self::contentTypes['getPIIDeletionJob'][0])
    {
        list($response) = $this->getPIIDeletionJobWithHttpInfo($engine_tenant_name, $job_id, $contentType);
        return $response;
    }

    /**
     * Operation getPIIDeletionJobWithHttpInfo
     *
     * Check the status of a PII deletion job with the provided job id.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $job_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\PIIDeletionResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPIIDeletionJobWithHttpInfo($engine_tenant_name, $job_id, string $contentType = self::contentTypes['getPIIDeletionJob'][0])
    {
        $request = $this->getPIIDeletionJobRequest($engine_tenant_name, $job_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\PIIDeletionResultSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\PIIDeletionResultSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\PIIDeletionResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPIIDeletionJobAsync
     *
     * Check the status of a PII deletion job with the provided job id.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $job_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPIIDeletionJobAsync($engine_tenant_name, $job_id, string $contentType = self::contentTypes['getPIIDeletionJob'][0])
    {
        return $this->getPIIDeletionJobAsyncWithHttpInfo($engine_tenant_name, $job_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPIIDeletionJobAsyncWithHttpInfo
     *
     * Check the status of a PII deletion job with the provided job id.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $job_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPIIDeletionJobAsyncWithHttpInfo($engine_tenant_name, $job_id, string $contentType = self::contentTypes['getPIIDeletionJob'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\PIIDeletionResultSchema';
        $request = $this->getPIIDeletionJobRequest($engine_tenant_name, $job_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPIIDeletionJob'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $job_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPIIDeletionJobRequest($engine_tenant_name, $job_id, string $contentType = self::contentTypes['getPIIDeletionJob'][0])
    {

        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getPIIDeletionJob'
            );
        }

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling getPIIDeletionJob'
            );
        }


        $resourcePath = '/appManagement/PII/deletionJob/{jobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubscription
     *
     * Returns a specific subscription
     *
     * @param  string $subscription_id subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscription'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SubscriptionEntrySchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getSubscription($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscription'][0])
    {
        list($response) = $this->getSubscriptionWithHttpInfo($subscription_id, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation getSubscriptionWithHttpInfo
     *
     * Returns a specific subscription
     *
     * @param  string $subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscription'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SubscriptionEntrySchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubscriptionWithHttpInfo($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscription'][0])
    {
        $request = $this->getSubscriptionRequest($subscription_id, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\SubscriptionEntrySchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\SubscriptionEntrySchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SubscriptionEntrySchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSubscriptionAsync
     *
     * Returns a specific subscription
     *
     * @param  string $subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionAsync($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscription'][0])
    {
        return $this->getSubscriptionAsyncWithHttpInfo($subscription_id, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubscriptionAsyncWithHttpInfo
     *
     * Returns a specific subscription
     *
     * @param  string $subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionAsyncWithHttpInfo($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscription'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SubscriptionEntrySchema';
        $request = $this->getSubscriptionRequest($subscription_id, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubscription'
     *
     * @param  string $subscription_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubscriptionRequest($subscription_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscription'][0])
    {

        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null || (is_array($subscription_id) && count($subscription_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_id when calling getSubscription'
            );
        }



        $resourcePath = '/appManagement/subscriptions/{subscriptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriptionId' . '}',
                ObjectSerializer::toPathValue($subscription_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubscriptionAuth
     *
     * Returns a specific subscription authentication configuration.
     *
     * @param  string $subscription_auth_id subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getSubscriptionAuth($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscriptionAuth'][0])
    {
        list($response) = $this->getSubscriptionAuthWithHttpInfo($subscription_auth_id, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation getSubscriptionAuthWithHttpInfo
     *
     * Returns a specific subscription authentication configuration.
     *
     * @param  string $subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubscriptionAuthWithHttpInfo($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscriptionAuth'][0])
    {
        $request = $this->getSubscriptionAuthRequest($subscription_auth_id, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSubscriptionAuthAsync
     *
     * Returns a specific subscription authentication configuration.
     *
     * @param  string $subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionAuthAsync($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscriptionAuth'][0])
    {
        return $this->getSubscriptionAuthAsyncWithHttpInfo($subscription_auth_id, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubscriptionAuthAsyncWithHttpInfo
     *
     * Returns a specific subscription authentication configuration.
     *
     * @param  string $subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionAuthAsyncWithHttpInfo($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscriptionAuth'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema';
        $request = $this->getSubscriptionAuthRequest($subscription_auth_id, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubscriptionAuth'
     *
     * @param  string $subscription_auth_id (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubscriptionAuthRequest($subscription_auth_id, $engine_tenant_name = null, string $contentType = self::contentTypes['getSubscriptionAuth'][0])
    {

        // verify the required parameter 'subscription_auth_id' is set
        if ($subscription_auth_id === null || (is_array($subscription_auth_id) && count($subscription_auth_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_auth_id when calling getSubscriptionAuth'
            );
        }



        $resourcePath = '/appManagement/subscriptions/authConfigurations/{subscriptionAuthId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($subscription_auth_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriptionAuthId' . '}',
                ObjectSerializer::toPathValue($subscription_auth_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubscriptionAuths
     *
     * Returns list of subscription authentication configurations
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuths'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SubscriptionAuthListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getSubscriptionAuths($engine_tenant_name = null, $more = null, string $contentType = self::contentTypes['getSubscriptionAuths'][0])
    {
        list($response) = $this->getSubscriptionAuthsWithHttpInfo($engine_tenant_name, $more, $contentType);
        return $response;
    }

    /**
     * Operation getSubscriptionAuthsWithHttpInfo
     *
     * Returns list of subscription authentication configurations
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuths'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SubscriptionAuthListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubscriptionAuthsWithHttpInfo($engine_tenant_name = null, $more = null, string $contentType = self::contentTypes['getSubscriptionAuths'][0])
    {
        $request = $this->getSubscriptionAuthsRequest($engine_tenant_name, $more, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\SubscriptionAuthListSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\SubscriptionAuthListSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SubscriptionAuthListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSubscriptionAuthsAsync
     *
     * Returns list of subscription authentication configurations
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuths'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionAuthsAsync($engine_tenant_name = null, $more = null, string $contentType = self::contentTypes['getSubscriptionAuths'][0])
    {
        return $this->getSubscriptionAuthsAsyncWithHttpInfo($engine_tenant_name, $more, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubscriptionAuthsAsyncWithHttpInfo
     *
     * Returns list of subscription authentication configurations
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuths'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionAuthsAsyncWithHttpInfo($engine_tenant_name = null, $more = null, string $contentType = self::contentTypes['getSubscriptionAuths'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SubscriptionAuthListSchema';
        $request = $this->getSubscriptionAuthsRequest($engine_tenant_name, $more, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubscriptionAuths'
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptionAuths'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubscriptionAuthsRequest($engine_tenant_name = null, $more = null, string $contentType = self::contentTypes['getSubscriptionAuths'][0])
    {




        $resourcePath = '/appManagement/subscriptions/authConfigurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $more,
            'more', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubscriptions
     *
     * Returns list of subscriptions
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string|null $topic Only subscriptions for the provided topic will be included (optional)
     * @param  string|null $subtopic Only subscriptions which specify the provided sub-topic will be included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptions'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SubscriptionListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getSubscriptions($engine_tenant_name = null, $more = null, $topic = null, $subtopic = null, string $contentType = self::contentTypes['getSubscriptions'][0])
    {
        list($response) = $this->getSubscriptionsWithHttpInfo($engine_tenant_name, $more, $topic, $subtopic, $contentType);
        return $response;
    }

    /**
     * Operation getSubscriptionsWithHttpInfo
     *
     * Returns list of subscriptions
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string|null $topic Only subscriptions for the provided topic will be included (optional)
     * @param  string|null $subtopic Only subscriptions which specify the provided sub-topic will be included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptions'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SubscriptionListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubscriptionsWithHttpInfo($engine_tenant_name = null, $more = null, $topic = null, $subtopic = null, string $contentType = self::contentTypes['getSubscriptions'][0])
    {
        $request = $this->getSubscriptionsRequest($engine_tenant_name, $more, $topic, $subtopic, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\SubscriptionListSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\SubscriptionListSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SubscriptionListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSubscriptionsAsync
     *
     * Returns list of subscriptions
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string|null $topic Only subscriptions for the provided topic will be included (optional)
     * @param  string|null $subtopic Only subscriptions which specify the provided sub-topic will be included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionsAsync($engine_tenant_name = null, $more = null, $topic = null, $subtopic = null, string $contentType = self::contentTypes['getSubscriptions'][0])
    {
        return $this->getSubscriptionsAsyncWithHttpInfo($engine_tenant_name, $more, $topic, $subtopic, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubscriptionsAsyncWithHttpInfo
     *
     * Returns list of subscriptions
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string|null $topic Only subscriptions for the provided topic will be included (optional)
     * @param  string|null $subtopic Only subscriptions which specify the provided sub-topic will be included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionsAsyncWithHttpInfo($engine_tenant_name = null, $more = null, $topic = null, $subtopic = null, string $contentType = self::contentTypes['getSubscriptions'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SubscriptionListSchema';
        $request = $this->getSubscriptionsRequest($engine_tenant_name, $more, $topic, $subtopic, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubscriptions'
     *
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  string|null $topic Only subscriptions for the provided topic will be included (optional)
     * @param  string|null $subtopic Only subscriptions which specify the provided sub-topic will be included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubscriptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubscriptionsRequest($engine_tenant_name = null, $more = null, $topic = null, $subtopic = null, string $contentType = self::contentTypes['getSubscriptions'][0])
    {






        $resourcePath = '/appManagement/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $more,
            'more', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $topic,
            'topic', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtopic,
            'subtopic', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenantList
     *
     * Get list of all tenants
     *
     * @param  bool|null $include_deactivated include_deactivated (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantList'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\TenantListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function getTenantList($include_deactivated = false, string $contentType = self::contentTypes['getTenantList'][0])
    {
        list($response) = $this->getTenantListWithHttpInfo($include_deactivated, $contentType);
        return $response;
    }

    /**
     * Operation getTenantListWithHttpInfo
     *
     * Get list of all tenants
     *
     * @param  bool|null $include_deactivated (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantList'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\TenantListSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenantListWithHttpInfo($include_deactivated = false, string $contentType = self::contentTypes['getTenantList'][0])
    {
        $request = $this->getTenantListRequest($include_deactivated, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\TenantListSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\TenantListSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\TenantListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTenantListAsync
     *
     * Get list of all tenants
     *
     * @param  bool|null $include_deactivated (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenantListAsync($include_deactivated = false, string $contentType = self::contentTypes['getTenantList'][0])
    {
        return $this->getTenantListAsyncWithHttpInfo($include_deactivated, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenantListAsyncWithHttpInfo
     *
     * Get list of all tenants
     *
     * @param  bool|null $include_deactivated (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenantListAsyncWithHttpInfo($include_deactivated = false, string $contentType = self::contentTypes['getTenantList'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\TenantListSchema';
        $request = $this->getTenantListRequest($include_deactivated, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenantList'
     *
     * @param  bool|null $include_deactivated (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTenantListRequest($include_deactivated = false, string $contentType = self::contentTypes['getTenantList'][0])
    {



        $resourcePath = '/appManagement/tenants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_deactivated,
            'includeDeactivated', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inspectToken
     *
     * Inspect token
     *
     * @param  string $token token (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inspectToken'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\TokenInfoSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function inspectToken($token, $engine_tenant_name = null, string $contentType = self::contentTypes['inspectToken'][0])
    {
        list($response) = $this->inspectTokenWithHttpInfo($token, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation inspectTokenWithHttpInfo
     *
     * Inspect token
     *
     * @param  string $token (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inspectToken'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\TokenInfoSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function inspectTokenWithHttpInfo($token, $engine_tenant_name = null, string $contentType = self::contentTypes['inspectToken'][0])
    {
        $request = $this->inspectTokenRequest($token, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\TokenInfoSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\TokenInfoSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\TokenInfoSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation inspectTokenAsync
     *
     * Inspect token
     *
     * @param  string $token (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inspectToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inspectTokenAsync($token, $engine_tenant_name = null, string $contentType = self::contentTypes['inspectToken'][0])
    {
        return $this->inspectTokenAsyncWithHttpInfo($token, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inspectTokenAsyncWithHttpInfo
     *
     * Inspect token
     *
     * @param  string $token (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inspectToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inspectTokenAsyncWithHttpInfo($token, $engine_tenant_name = null, string $contentType = self::contentTypes['inspectToken'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\TokenInfoSchema';
        $request = $this->inspectTokenRequest($token, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inspectToken'
     *
     * @param  string $token (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inspectToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function inspectTokenRequest($token, $engine_tenant_name = null, string $contentType = self::contentTypes['inspectToken'][0])
    {

        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling inspectToken'
            );
        }



        $resourcePath = '/appManagement/token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPIIDeletionJob
     *
     * Initiate a job to delete a user&#39;s Personal Identifying Information from the system.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\PIIDeletionRequestSchema $entities entities (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\PIIDeletionRequestResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function postPIIDeletionJob($engine_tenant_name, $entities, string $contentType = self::contentTypes['postPIIDeletionJob'][0])
    {
        list($response) = $this->postPIIDeletionJobWithHttpInfo($engine_tenant_name, $entities, $contentType);
        return $response;
    }

    /**
     * Operation postPIIDeletionJobWithHttpInfo
     *
     * Initiate a job to delete a user&#39;s Personal Identifying Information from the system.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\PIIDeletionRequestSchema $entities (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\PIIDeletionRequestResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPIIDeletionJobWithHttpInfo($engine_tenant_name, $entities, string $contentType = self::contentTypes['postPIIDeletionJob'][0])
    {
        $request = $this->postPIIDeletionJobRequest($engine_tenant_name, $entities, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\PIIDeletionRequestResultSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\PIIDeletionRequestResultSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\PIIDeletionRequestResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postPIIDeletionJobAsync
     *
     * Initiate a job to delete a user&#39;s Personal Identifying Information from the system.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\PIIDeletionRequestSchema $entities (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPIIDeletionJobAsync($engine_tenant_name, $entities, string $contentType = self::contentTypes['postPIIDeletionJob'][0])
    {
        return $this->postPIIDeletionJobAsyncWithHttpInfo($engine_tenant_name, $entities, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPIIDeletionJobAsyncWithHttpInfo
     *
     * Initiate a job to delete a user&#39;s Personal Identifying Information from the system.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\PIIDeletionRequestSchema $entities (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPIIDeletionJobAsyncWithHttpInfo($engine_tenant_name, $entities, string $contentType = self::contentTypes['postPIIDeletionJob'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\PIIDeletionRequestResultSchema';
        $request = $this->postPIIDeletionJobRequest($engine_tenant_name, $entities, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPIIDeletionJob'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\PIIDeletionRequestSchema $entities (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPIIDeletionJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postPIIDeletionJobRequest($engine_tenant_name, $entities, string $contentType = self::contentTypes['postPIIDeletionJob'][0])
    {

        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling postPIIDeletionJob'
            );
        }

        // verify the required parameter 'entities' is set
        if ($entities === null || (is_array($entities) && count($entities) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entities when calling postPIIDeletionJob'
            );
        }


        $resourcePath = '/appManagement/PII/deletionJob';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($entities)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($entities));
            } else {
                $httpBody = $entities;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postUpdateEncryptedSetting
     *
     * Re-write settings, and statement pipe passwords using the current encryption settings. For password rotation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUpdateEncryptedSetting'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postUpdateEncryptedSetting($engine_tenant_name, string $contentType = self::contentTypes['postUpdateEncryptedSetting'][0])
    {
        $this->postUpdateEncryptedSettingWithHttpInfo($engine_tenant_name, $contentType);
    }

    /**
     * Operation postUpdateEncryptedSettingWithHttpInfo
     *
     * Re-write settings, and statement pipe passwords using the current encryption settings. For password rotation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUpdateEncryptedSetting'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postUpdateEncryptedSettingWithHttpInfo($engine_tenant_name, string $contentType = self::contentTypes['postUpdateEncryptedSetting'][0])
    {
        $request = $this->postUpdateEncryptedSettingRequest($engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postUpdateEncryptedSettingAsync
     *
     * Re-write settings, and statement pipe passwords using the current encryption settings. For password rotation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUpdateEncryptedSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUpdateEncryptedSettingAsync($engine_tenant_name, string $contentType = self::contentTypes['postUpdateEncryptedSetting'][0])
    {
        return $this->postUpdateEncryptedSettingAsyncWithHttpInfo($engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postUpdateEncryptedSettingAsyncWithHttpInfo
     *
     * Re-write settings, and statement pipe passwords using the current encryption settings. For password rotation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUpdateEncryptedSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUpdateEncryptedSettingAsyncWithHttpInfo($engine_tenant_name, string $contentType = self::contentTypes['postUpdateEncryptedSetting'][0])
    {
        $returnType = '';
        $request = $this->postUpdateEncryptedSettingRequest($engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postUpdateEncryptedSetting'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUpdateEncryptedSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postUpdateEncryptedSettingRequest($engine_tenant_name, string $contentType = self::contentTypes['postUpdateEncryptedSetting'][0])
    {

        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling postUpdateEncryptedSetting'
            );
        }


        $resourcePath = '/appManagement/configuration/updateEncryptedSettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetCredentialSecret
     *
     * Reset credential secret
     *
     * @param  string $credential_id credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetCredentialSecret'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema
     */
    public function resetCredentialSecret($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['resetCredentialSecret'][0])
    {
        list($response) = $this->resetCredentialSecretWithHttpInfo($credential_id, $engine_tenant_name, $contentType);
        return $response;
    }

    /**
     * Operation resetCredentialSecretWithHttpInfo
     *
     * Reset credential secret
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetCredentialSecret'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\StringResultSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema|\RusticiSoftware\Engine\V2\Model\MessageSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetCredentialSecretWithHttpInfo($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['resetCredentialSecret'][0])
    {
        $request = $this->resetCredentialSecretRequest($credential_id, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation resetCredentialSecretAsync
     *
     * Reset credential secret
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetCredentialSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetCredentialSecretAsync($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['resetCredentialSecret'][0])
    {
        return $this->resetCredentialSecretAsyncWithHttpInfo($credential_id, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetCredentialSecretAsyncWithHttpInfo
     *
     * Reset credential secret
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetCredentialSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetCredentialSecretAsyncWithHttpInfo($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['resetCredentialSecret'][0])
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->resetCredentialSecretRequest($credential_id, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetCredentialSecret'
     *
     * @param  string $credential_id (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetCredentialSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resetCredentialSecretRequest($credential_id, $engine_tenant_name = null, string $contentType = self::contentTypes['resetCredentialSecret'][0])
    {

        // verify the required parameter 'credential_id' is set
        if ($credential_id === null || (is_array($credential_id) && count($credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_id when calling resetCredentialSecret'
            );
        }



        $resourcePath = '/appManagement/credentials/{credentialId}/resetSecret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialId' . '}',
                ObjectSerializer::toPathValue($credential_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setApplicationConfiguration
     *
     * Set configuration settings for this level.
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setApplicationConfiguration($configuration_settings, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['setApplicationConfiguration'][0])
    {
        $this->setApplicationConfigurationWithHttpInfo($configuration_settings, $engine_tenant_name, $learning_standard, $single_sco, $contentType);
    }

    /**
     * Operation setApplicationConfigurationWithHttpInfo
     *
     * Set configuration settings for this level.
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setApplicationConfigurationWithHttpInfo($configuration_settings, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['setApplicationConfiguration'][0])
    {
        $request = $this->setApplicationConfigurationRequest($configuration_settings, $engine_tenant_name, $learning_standard, $single_sco, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setApplicationConfigurationAsync
     *
     * Set configuration settings for this level.
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setApplicationConfigurationAsync($configuration_settings, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['setApplicationConfiguration'][0])
    {
        return $this->setApplicationConfigurationAsyncWithHttpInfo($configuration_settings, $engine_tenant_name, $learning_standard, $single_sco, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setApplicationConfigurationAsyncWithHttpInfo
     *
     * Set configuration settings for this level.
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setApplicationConfigurationAsyncWithHttpInfo($configuration_settings, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['setApplicationConfiguration'][0])
    {
        $returnType = '';
        $request = $this->setApplicationConfigurationRequest($configuration_settings, $engine_tenant_name, $learning_standard, $single_sco, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setApplicationConfiguration'
     *
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string|null $learning_standard Required if singleSco is specified. Scopes the request to the provided learning standard. (optional)
     * @param  bool|null $single_sco Required if learningStandard is specified. Scopes settings to whether a package has only one SCO or assignable unit within it or not. To apply a configuration setting to a learning standard for single and multi-SCO content, it must be set for both scopes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setApplicationConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setApplicationConfigurationRequest($configuration_settings, $engine_tenant_name = null, $learning_standard = null, $single_sco = null, string $contentType = self::contentTypes['setApplicationConfiguration'][0])
    {

        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setApplicationConfiguration'
            );
        }





        $resourcePath = '/appManagement/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $learning_standard,
            'learningStandard', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single_sco,
            'singleSco', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($configuration_settings)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($configuration_settings));
            } else {
                $httpBody = $configuration_settings;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCredential
     *
     * Update &#x60;credentialId&#x60; credentials
     *
     * @param  string $credential_id credential_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_update credential_update (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateCredential($credential_id, $credential_update, $engine_tenant_name = null, string $contentType = self::contentTypes['updateCredential'][0])
    {
        $this->updateCredentialWithHttpInfo($credential_id, $credential_update, $engine_tenant_name, $contentType);
    }

    /**
     * Operation updateCredentialWithHttpInfo
     *
     * Update &#x60;credentialId&#x60; credentials
     *
     * @param  string $credential_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_update (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCredential'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCredentialWithHttpInfo($credential_id, $credential_update, $engine_tenant_name = null, string $contentType = self::contentTypes['updateCredential'][0])
    {
        $request = $this->updateCredentialRequest($credential_id, $credential_update, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCredentialAsync
     *
     * Update &#x60;credentialId&#x60; credentials
     *
     * @param  string $credential_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_update (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCredentialAsync($credential_id, $credential_update, $engine_tenant_name = null, string $contentType = self::contentTypes['updateCredential'][0])
    {
        return $this->updateCredentialAsyncWithHttpInfo($credential_id, $credential_update, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCredentialAsyncWithHttpInfo
     *
     * Update &#x60;credentialId&#x60; credentials
     *
     * @param  string $credential_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_update (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCredentialAsyncWithHttpInfo($credential_id, $credential_update, $engine_tenant_name = null, string $contentType = self::contentTypes['updateCredential'][0])
    {
        $returnType = '';
        $request = $this->updateCredentialRequest($credential_id, $credential_update, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCredential'
     *
     * @param  string $credential_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CredentialRequestSchema $credential_update (required)
     * @param  string|null $engine_tenant_name If specified, the tenant that will be used to store or validate the credentials or token. If not specified, the system data store / settings will be used. Note that PermissionsSchema contains &#39;tenantName&#39; which should be used for any permissions that need to be scoped to a particular tenant. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCredential'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCredentialRequest($credential_id, $credential_update, $engine_tenant_name = null, string $contentType = self::contentTypes['updateCredential'][0])
    {

        // verify the required parameter 'credential_id' is set
        if ($credential_id === null || (is_array($credential_id) && count($credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_id when calling updateCredential'
            );
        }

        // verify the required parameter 'credential_update' is set
        if ($credential_update === null || (is_array($credential_update) && count($credential_update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_update when calling updateCredential'
            );
        }



        $resourcePath = '/appManagement/credentials/{credentialId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialId' . '}',
                ObjectSerializer::toPathValue($credential_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($credential_update)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($credential_update));
            } else {
                $httpBody = $credential_update;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSubscription
     *
     * Update subscription. Partial updates not supported.
     *
     * @param  string $subscription_id subscription_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateSubscription($subscription_id, $subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscription'][0])
    {
        $this->updateSubscriptionWithHttpInfo($subscription_id, $subscription_definition, $engine_tenant_name, $contentType);
    }

    /**
     * Operation updateSubscriptionWithHttpInfo
     *
     * Update subscription. Partial updates not supported.
     *
     * @param  string $subscription_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSubscriptionWithHttpInfo($subscription_id, $subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscription'][0])
    {
        $request = $this->updateSubscriptionRequest($subscription_id, $subscription_definition, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateSubscriptionAsync
     *
     * Update subscription. Partial updates not supported.
     *
     * @param  string $subscription_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSubscriptionAsync($subscription_id, $subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscription'][0])
    {
        return $this->updateSubscriptionAsyncWithHttpInfo($subscription_id, $subscription_definition, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSubscriptionAsyncWithHttpInfo
     *
     * Update subscription. Partial updates not supported.
     *
     * @param  string $subscription_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSubscriptionAsyncWithHttpInfo($subscription_id, $subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscription'][0])
    {
        $returnType = '';
        $request = $this->updateSubscriptionRequest($subscription_id, $subscription_definition, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSubscription'
     *
     * @param  string $subscription_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionDefinitionSchema $subscription_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateSubscriptionRequest($subscription_id, $subscription_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscription'][0])
    {

        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null || (is_array($subscription_id) && count($subscription_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_id when calling updateSubscription'
            );
        }

        // verify the required parameter 'subscription_definition' is set
        if ($subscription_definition === null || (is_array($subscription_definition) && count($subscription_definition) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_definition when calling updateSubscription'
            );
        }



        $resourcePath = '/appManagement/subscriptions/{subscriptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriptionId' . '}',
                ObjectSerializer::toPathValue($subscription_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_definition)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_definition));
            } else {
                $httpBody = $subscription_definition;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSubscriptionAuth
     *
     * Update subscription authentication configuration. Partial updates not supported.
     *
     * @param  string $subscription_auth_id subscription_auth_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateSubscriptionAuth($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscriptionAuth'][0])
    {
        $this->updateSubscriptionAuthWithHttpInfo($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name, $contentType);
    }

    /**
     * Operation updateSubscriptionAuthWithHttpInfo
     *
     * Update subscription authentication configuration. Partial updates not supported.
     *
     * @param  string $subscription_auth_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSubscriptionAuthWithHttpInfo($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscriptionAuth'][0])
    {
        $request = $this->updateSubscriptionAuthRequest($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateSubscriptionAuthAsync
     *
     * Update subscription authentication configuration. Partial updates not supported.
     *
     * @param  string $subscription_auth_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSubscriptionAuthAsync($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscriptionAuth'][0])
    {
        return $this->updateSubscriptionAuthAsyncWithHttpInfo($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSubscriptionAuthAsyncWithHttpInfo
     *
     * Update subscription authentication configuration. Partial updates not supported.
     *
     * @param  string $subscription_auth_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSubscriptionAuthAsyncWithHttpInfo($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscriptionAuth'][0])
    {
        $returnType = '';
        $request = $this->updateSubscriptionAuthRequest($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSubscriptionAuth'
     *
     * @param  string $subscription_auth_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SubscriptionAuthDefinitionSchema $subscription_auth_definition (required)
     * @param  string|null $engine_tenant_name optional tenant for this request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSubscriptionAuth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateSubscriptionAuthRequest($subscription_auth_id, $subscription_auth_definition, $engine_tenant_name = null, string $contentType = self::contentTypes['updateSubscriptionAuth'][0])
    {

        // verify the required parameter 'subscription_auth_id' is set
        if ($subscription_auth_id === null || (is_array($subscription_auth_id) && count($subscription_auth_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_auth_id when calling updateSubscriptionAuth'
            );
        }

        // verify the required parameter 'subscription_auth_definition' is set
        if ($subscription_auth_definition === null || (is_array($subscription_auth_definition) && count($subscription_auth_definition) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscription_auth_definition when calling updateSubscriptionAuth'
            );
        }



        $resourcePath = '/appManagement/subscriptions/authConfigurations/{subscriptionAuthId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($subscription_auth_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriptionAuthId' . '}',
                ObjectSerializer::toPathValue($subscription_auth_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_auth_definition)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_auth_definition));
            } else {
                $httpBody = $subscription_auth_definition;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
